# 强化 Ask 模式设计文档

> **状态**: ✅ 已实现 | **实现日期**: 2025-02-18
>
> **实现摘要**: Core 层通过 `beforeToolExecute` 钩子强制执行只读限制，交互层状态统一由 `currentConfig.mode` 管理。

---

## 1. 背景与动机

### 当前问题

KodaX 目前在交互式 REPL 中支持 `code` 和 `ask` 两种模式，但 `ask` 模式仅在 REPL 层设置了一个标记，**Core 层并未强制执行只读限制**。这意味着：

1. 用户切换到 `ask` 模式后，AI 仍然可能调用 `write`、`edit`、`bash` 等修改性工具
2. 用户无法放心地使用 `ask` 模式进行代码审查或咨询，因为存在意外修改的风险
3. 与 Claude Code 的 Ask Mode 相比，功能完整性存在明显差距

### 用户场景

- **代码审查**：用户想讨论代码设计方案，但不想意外修改文件
- **安全咨询**：在不确定的环境中运行 KodaX，希望确保不会修改任何文件
- **学习探索**：新手用户想先了解 KodaX 的能力，再决定是否启用修改权限

## 2. 设计目标

遵循 KodaX "极简且智能" 的设计原则：

1. **强制性**：`ask` 模式下必须真正禁止文件修改操作
2. **透明性**：当 AI 尝试调用被禁用的工具时，给用户提供清晰的反馈
3. **易切换**：用户可以方便地在 `code` 和 `ask` 模式间切换
4. **向后兼容**：不影响现有 `code` 模式的默认行为

## 3. 方案对比

### 方案 A：工具层过滤（推荐）

在 `executeTool` 函数中检查当前模式，直接拒绝修改性工具的调用。

**优点**：
- 实现简单，改动范围小
- 安全性高，在底层强制执行
- 对 AI 的提示无需修改

**缺点**：
- AI 不知道自己在 ask 模式，可能会反复尝试调用被禁用的工具

### 方案 B：系统提示层控制

在系统提示中根据模式动态添加约束，告诉 AI 当前只能使用只读工具。

**优点**：
- AI 会主动避免调用修改性工具
- 用户体验更流畅

**缺点**：
- 依赖 AI 遵循提示，不是强制性的
- 需要修改系统提示构建逻辑

### 方案 C：组合方案（最终选择）

结合方案 A 和方案 B：
1. 在系统提示中告知 AI 当前模式及可用工具
2. 在工具执行层强制执行权限检查（双重保险）

## 4. 最终方案

### 4.1 核心设计

```
┌─────────────────────────────────────────────────────────────┐
│                        KodaXOptions                          │
│                    (新增 mode 字段)                          │
└──────────────────────┬──────────────────────────────────────┘
                       │
         ┌─────────────┴─────────────┐
         │                           │
         ▼                           ▼
┌─────────────────┐        ┌─────────────────┐
│  buildSystemPrompt│        │ executeTool     │
│  (告知AI可用工具) │        │ (强制执行权限)   │
└─────────────────┘        └─────────────────┘
```

### 4.2 数据模型修改

**文件**: `src/kodax_core.ts`

```typescript
// 新增：交互模式类型
export type KodaXInteractionMode = 'code' | 'ask';

export interface KodaXOptions {
  provider: string;
  thinking?: boolean;
  maxIter?: number;
  parallel?: boolean;
  auto?: boolean;
  mode?: KodaXInteractionMode;  // 新增：交互模式，默认 'code'
  confirmTools?: Set<string>;
  session?: KodaXSessionOptions;
  context?: KodaXContextOptions;
  events: KodaXEvents;
}
```

### 4.3 工具执行层处理

**文件**: `src/kodax_core.ts` (executeTool 函数)

```typescript
// Ask 模式下需要确认的工具
const ASK_MODE_CONFIRM_TOOLS = new Set(['write', 'edit', 'bash', 'notebook_edit']);

export async function executeTool(
  name: string,
  input: Record<string, unknown>,
  ctx: KodaXToolExecutionContext
): Promise<string> {
  // Ask 模式下修改性工具返回特殊标记，由 CLI 层处理确认
  if (ctx.mode === 'ask' && ASK_MODE_CONFIRM_TOOLS.has(name)) {
    return `[AskModeConfirm] Tool "${name}" requires code mode confirmation`;
  }
  // ... 原有逻辑
}
```

### 4.4 系统提示层增强

**文件**: `src/kodax_core.ts` (buildSystemPrompt 函数)

```typescript
async function buildSystemPrompt(
  options: KodaXOptions,
  isFirstMessage: boolean
): Promise<string> {
  // ... 原有系统提示构建逻辑

  // 根据模式添加可用工具说明
  if (options.mode === 'ask') {
    lines.push('');
    lines.push('## Current Mode: ASK');
    lines.push('You are in "ask" mode (read-only). You can ONLY use the following tools:');
    lines.push('- read: Read file contents');
    lines.push('- glob: Find files matching a pattern');
    lines.push('- grep: Search for patterns in files');
    lines.push('- undo: Undo the last file operation');
    lines.push('');
    lines.push('You CANNOT use write, edit, bash, or notebook_edit in this mode.');
    lines.push('If the user requests a file modification, explain what you would do but do not execute it.');
  }

  return lines.join('\n');
}
```

### 4.5 CLI 层集成

**文件**: `src/kodax_cli.ts`

```typescript
function createKodaXOptions(cliOptions: CliOptions): KodaXOptions {
  return {
    // ... 其他选项
    mode: cliOptions.mode ?? 'code',  // 默认 code 模式
    // ...
  };
}
```

### 4.6 交互式 REPL 层增强

**文件**: `src/interactive/commands.ts`

当前 `/mode` 命令仅设置标记，需要增强以同步到 Core 层：

```typescript
{
  name: 'mode',
  aliases: ['m'],
  description: 'Switch between code and ask mode',
  usage: '/mode [code|ask]',
  handler: async (args, context) => {
    const newMode = args[0]?.toLowerCase() as 'code' | 'ask';
    if (!newMode || !['code', 'ask'].includes(newMode)) {
      console.log(chalk.yellow('\nUsage: /mode [code|ask]'));
      console.log(chalk.dim(`Current mode: ${context.mode}`));
      return;
    }

    // 更新上下文
    setMode(context, newMode);

    const icon = newMode === 'code' ? '💻' : '💬';
    console.log(chalk.cyan(`\n${icon} Switched to ${newMode} mode`));

    if (newMode === 'ask') {
      console.log(chalk.dim('Read-only mode: modifying tools require confirmation'));
    }
  },
}
```

**文件**: `src/interactive/repl.ts`

在 REPL 中处理 `[AskModeConfirm]` 标记，询问用户是否临时切换：

```typescript
// 在事件处理中捕获 AskModeConfirm
const options: KodaXOptions = {
  // ...
  mode: context.mode,
  events: {
    onToolResult: (result) => {
      // 检查结果是否包含 AskModeConfirm
      if (result.content.includes('[AskModeConfirm]')) {
        // 询问用户是否切换
        const switchMode = await confirm(
          `💬 [Ask Mode] This operation will modify files.\n` +
          `Switch to code mode temporarily? (y/n) `
        );

        if (switchMode) {
          // 临时切换到 code 模式重新执行
          context.mode = 'code';
          // 重新执行当前请求...
          // 执行完成后自动切回 ask
          context.mode = 'ask';
          console.log(chalk.dim('💬 Back to ask mode'));
        }
      }
    }
  }
};
```

## 5. 实现计划

### 任务拆分

| 任务 | 文件 | 工作量 | 优先级 |
|------|------|--------|--------|
| 1. 添加 mode 类型定义 | `src/kodax_core.ts` | 小 | P0 |
| 2. 工具层强制执行 | `src/kodax_core.ts` | 小 | P0 |
| 3. 系统提示增强 | `src/kodax_core.ts` | 小 | P0 |
| 4. CLI 层传递 mode | `src/kodax_cli.ts` | 小 | P0 |
| 5. REPL 层同步 mode | `src/interactive/*.ts` | 中 | P0 |
| 6. 添加单元测试 | `tests/**/*.test.ts` | 中 | P1 |
| 7. 更新文档 | `docs/**/*.md` | 小 | P1 |

### 验证清单

- [ ] `/mode ask` 后，AI 调用 `write` 返回错误提示
- [ ] `/mode ask` 后，系统提示中包含可用工具列表
- [ ] `/mode code` 后，所有工具恢复正常使用
- [ ] 切换模式后，当前会话上下文保持（消息历史不丢失）
- [ ] 配置文件正确保存/加载 mode 设置

## 6. 风险与回滚

### 潜在风险

| 风险 | 可能性 | 影响 | 应对措施 |
|------|--------|------|----------|
| AI 不理解模式限制，反复尝试被禁用的工具 | 中 | 用户体验差 | 清晰的系统提示 + 友好的错误信息 |
| 模式切换时状态不同步 | 低 | 安全漏洞 | 代码审查 + 单元测试覆盖 |
| 向后兼容性破坏 | 低 | 现有功能异常 | 默认值为 'code'，与现有行为一致 |

### 回滚方案

如需要回滚，只需：
1. 移除 `mode` 相关的系统提示文本
2. 工具层检查保持存在但默认为 'code'，不影响功能

## 7. 与 Claude Code 的对比

| 功能 | Claude Code | KodaX (强化后) |
|------|-------------|----------------|
| Ask 模式强制执行 | 是 | 是 |
| 工具白名单 | read, glob, grep | read, glob, grep, undo |
| 模式切换命令 | `/ask`, `/code` | `/mode ask`, `/mode code` |
| 用户提示 | 清晰区分 | 增强后清晰区分 |

## 8. 后续优化方向

1. **模式持久化**：记住用户上次的模式选择
2. **目录级模式**：某些目录默认进入 ask 模式（如生产环境配置目录）
3. **工具级权限**：允许用户自定义 ask 模式下可用的工具
