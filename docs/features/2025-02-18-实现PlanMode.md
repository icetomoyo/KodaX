# å®ç° Plan Mode è®¾è®¡æ–‡æ¡£ï¼ˆæœ€ç»ˆç‰ˆï¼‰

> **è®¾è®¡åŸåˆ™**ï¼šCore å±‚æç®€ï¼ŒCLI å±‚å®ç°å…¨éƒ¨å¤æ‚é€»è¾‘

---

## 1. èƒŒæ™¯ä¸åŠ¨æœº

### å½“å‰é—®é¢˜

KodaX ç›®å‰å¯¹äºå¤æ‚ä»»åŠ¡ä¼šç›´æ¥æ‰§è¡Œï¼Œç¼ºä¹**æ‰§è¡Œå‰çš„è®¡åˆ’ç¡®è®¤ç¯èŠ‚**ï¼š

1. **ä¸å¯é¢„æµ‹æ€§**ï¼šç”¨æˆ·ä¸çŸ¥é“ AI å°†è¦æ‰§è¡Œå“ªäº›æ“ä½œ
2. **é”™è¯¯æˆæœ¬é«˜**ï¼šAI çš„é”™è¯¯æ“ä½œå¯èƒ½ç›´æ¥ä¿®æ”¹æ–‡ä»¶
3. **æ— æ³•ä¸­æ–­æ¢å¤**ï¼šé•¿æ—¶é—´ä»»åŠ¡ä¸­æ–­åéœ€è¦é‡æ–°å¼€å§‹

### ç”¨æˆ·åœºæ™¯

- **é‡æ„é¡¹ç›®**ï¼šå¤šæ–‡ä»¶ä¿®æ”¹ï¼Œå¸Œæœ›çœ‹åˆ°å®Œæ•´å˜æ›´è®¡åˆ’
- **å®‰å…¨å®¡æŸ¥**ï¼šå…³é”®ç¯å¢ƒéœ€è¦äººå·¥å®¡æ ¸æ¯æ­¥æ“ä½œ
- **é•¿æ—¶é—´ä»»åŠ¡**ï¼šéœ€è¦ä¸­æ–­åèƒ½æ¢å¤ç»§ç»­æ‰§è¡Œ

---

## 2. è®¾è®¡ç›®æ ‡

éµå¾ª KodaX "æç®€ä¸”æ™ºèƒ½" çš„è®¾è®¡åŸåˆ™ï¼š

1. **Core å±‚æç®€**ï¼šåªå¢åŠ ä¸€ä¸ªé’©å­ï¼Œå…¶ä½™é€»è¾‘åœ¨ CLI å±‚
2. **æ–‡æœ¬è®¡åˆ’**ï¼šä¸ä¾èµ– JSON ç»“æ„åŒ–ï¼Œé¿å…è§£æå¤±è´¥
3. **ä¸­æ–­æ¢å¤**ï¼šæ”¯æŒä¿å­˜è®¡åˆ’ã€æ¢å¤æ‰§è¡Œ
4. **é€æ­¥ç¡®è®¤**ï¼šæ¯æ­¥æ‰§è¡Œå‰å¯ç¡®è®¤/è·³è¿‡

---

## 3. æ–¹æ¡ˆå¯¹æ¯”

| æ–¹æ¡ˆ | æè¿° | ä¼˜ç‚¹ | ç¼ºç‚¹ | å†³ç­– |
|------|------|------|------|------|
| **A. JSON ç»“æ„åŒ–** | AI è¾“å‡º JSONï¼Œç¨‹åºè§£æ | ç»“æ„åŒ–ã€å¯ç¼–ç¨‹ | ä¾èµ– AI è¾“å‡ºå¯é  JSONï¼Œè„†å¼± | âŒ ä¸é‡‡ç”¨ |
| **B. æ–‡æœ¬è®¡åˆ’** | AI è¾“å‡ºæ–‡æœ¬ï¼Œç®€å•è§£æ | çµæ´»ã€å®¹é”™ã€æ˜“è°ƒè¯• | éœ€è¦ç®€å•è§£æé€»è¾‘ | âœ… **é‡‡ç”¨** |
| **C. Core å±‚å®ç°** | Core å±‚åŒ…å«è®¡åˆ’é€»è¾‘ | ç»Ÿä¸€å¤„ç† | è¿èƒŒ Core æç®€åŸåˆ™ | âŒ ä¸é‡‡ç”¨ |
| **D. CLI å±‚å®ç°** | CLI å±‚åŒ…å«å…¨éƒ¨é€»è¾‘ | Core ä¿æŒæç®€ï¼ŒCLI çµæ´» | éœ€è¦æ›´å¤š CLI ä»£ç  | âœ… **é‡‡ç”¨** |

---

## 4. æœ€ç»ˆæ–¹æ¡ˆ

### 4.1 æ ¸å¿ƒåŸåˆ™

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      åˆ†å±‚æ¶æ„                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚   CLI å±‚ï¼ˆå¤æ‚äº¤äº’ï¼‰                                      â”‚
â”‚   â”œâ”€â”€ è®¡åˆ’ç”Ÿæˆï¼ˆç‰¹æ®Šæç¤ºè¯ï¼‰                               â”‚
â”‚   â”œâ”€â”€ è®¡åˆ’å­˜å‚¨ï¼ˆæ–‡ä»¶ç³»ç»Ÿï¼‰                                â”‚
â”‚   â”œâ”€â”€ è®¡åˆ’å±•ç¤ºï¼ˆæ–‡æœ¬è¡¨æ ¼ï¼‰                                â”‚
â”‚   â””â”€â”€ æ­¥éª¤ç¡®è®¤ï¼ˆç”¨æˆ·äº¤äº’ï¼‰                                â”‚
â”‚              â”‚                                          â”‚
â”‚              â–¼                                          â”‚
â”‚   Core å±‚ï¼ˆæç®€ - ä»… 1 ä¸ªé’©å­ï¼‰                           â”‚
â”‚   â””â”€â”€ beforeToolExecute: æ‰§è¡Œå‰ç¡®è®¤                      â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 Core å±‚æ”¹åŠ¨ï¼ˆæç®€ï¼‰

**æ–‡ä»¶**: `src/kodax_core.ts`

```typescript
// 1. å·¥å…·æ‰§è¡Œä¸Šä¸‹æ–‡æ–°å¢é’©å­ï¼ˆå”¯ä¸€æ”¹åŠ¨ï¼‰
export interface KodaXToolExecutionContext {
  // ... ç°æœ‰å­—æ®µ
  confirmTools: Set<string>;
  backups: Map<string, string>;
  auto: boolean;
  onConfirm?: (tool: string, input: Record<string, unknown>) => Promise<boolean>;
  beforeToolExecute?: (tool: string, input: Record<string, unknown>) => Promise<boolean>;  // æ–°å¢
}

// 2. executeTool å‡½æ•°ä¸­è°ƒç”¨
export async function executeTool(
  name: string,
  input: Record<string, unknown>,
  ctx: KodaXToolExecutionContext
): Promise<string> {
  // æ–°å¢ï¼šæ‰§è¡Œå‰é’©å­
  if (ctx.beforeToolExecute) {
    const shouldContinue = await ctx.beforeToolExecute(name, input);
    if (!shouldContinue) return '[Cancelled by user]';
  }

  // ... åŸæœ‰é€»è¾‘
}
```

### 4.3 CLI å±‚å®ç°ï¼ˆå…¨éƒ¨å¤æ‚é€»è¾‘ï¼‰

#### 4.3.1 è®¡åˆ’å­˜å‚¨

**æ–‡ä»¶**: `src/cli/plan-storage.ts`

```typescript
import path from 'path';
import fs from 'fs/promises';
import { KODAX_DIR } from '../kodax_core.js';

export interface ExecutionPlan {
  id: string;
  title: string;
  originalPrompt: string;
  steps: {
    id: string;
    description: string;
    tool?: string;
    input?: Record<string, unknown>;
    status: 'pending' | 'done' | 'skipped' | 'failed';
    executedAt?: Date;
  }[];
  createdAt: Date;
  updatedAt: Date;
}

export class PlanStorage {
  private dir = path.join(KODAX_DIR, 'plans');

  async save(plan: ExecutionPlan): Promise<void> {
    await fs.mkdir(this.dir, { recursive: true });
    const filePath = path.join(this.dir, `${plan.id}.json`);
    await fs.writeFile(filePath, JSON.stringify(plan, null, 2));
  }

  async load(planId: string): Promise<ExecutionPlan | null> {
    try {
      const filePath = path.join(this.dir, `${planId}.json`);
      const content = await fs.readFile(filePath, 'utf-8');
      return JSON.parse(content);
    } catch {
      return null;
    }
  }

  async list(): Promise<ExecutionPlan[]> {
    try {
      const files = await fs.readdir(this.dir);
      const plans = await Promise.all(
        files
          .filter(f => f.endsWith('.json'))
          .map(f => this.load(f.replace('.json', '')))
      );
      return plans.filter((p): p is ExecutionPlan => p !== null);
    } catch {
      return [];
    }
  }

  async findPending(): Promise<ExecutionPlan | null> {
    const plans = await this.list();
    return plans.find(p =>
      p.steps.some(s => s.status === 'pending')
    ) || null;
  }

  async delete(planId: string): Promise<void> {
    const filePath = path.join(this.dir, `${planId}.json`);
    await fs.unlink(filePath).catch(() => {});
  }
}

export const planStorage = new PlanStorage();
```

#### 4.3.2 Plan Mode ä¸»é€»è¾‘

**æ–‡ä»¶**: `src/cli/plan-mode.ts`

```typescript
import { runKodaX, KodaXOptions } from '../kodax_core.js';
import { planStorage, ExecutionPlan } from './plan-storage.js';
import chalk from 'chalk';
import readline from 'readline';

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

async function confirm(message: string): Promise<boolean> {
  return new Promise(resolve => {
    rl.question(`${message} (y/n) `, answer => {
      resolve(answer.toLowerCase().startsWith('y'));
    });
  });
}

// ç”Ÿæˆè®¡åˆ’æç¤ºè¯
const PLAN_GENERATION_PROMPT = `You are in PLAN MODE. Do not execute any tools yet.

Analyze the user's request and create a detailed execution plan.

Respond with a simple text plan in this format:

PLAN: <Brief title>

Steps:
1. [ACTION] <description> - <target file/command>
2. [ACTION] <description> - <target file/command>
...

Available actions: READ, WRITE, EDIT, BASH, EXPLAIN

Example:
PLAN: Add User Authentication

Steps:
1. [READ] Check current project structure - .
2. [READ] Check dependencies - package.json
3. [WRITE] Create auth middleware - src/middleware/auth.ts
4. [EDIT] Add auth routes - src/routes/index.ts
5. [EXPLAIN] Explain how to use the new auth system
`;

async function generatePlan(prompt: string, options: KodaXOptions): Promise<string> {
  const planMessages = [
    { role: 'system', content: PLAN_GENERATION_PROMPT },
    { role: 'user', content: prompt }
  ];

  const result = await runKodaX({
    ...options,
    maxIter: 1,  // åªç”Ÿæˆè®¡åˆ’ï¼Œä¸æ‰§è¡Œ
  }, prompt + '\n\n[Please generate a plan only, do not execute tools]');

  return result.lastText || '';
}

// ç®€å•è§£ææ–‡æœ¬è®¡åˆ’
function parsePlanText(text: string, originalPrompt: string): ExecutionPlan {
  const lines = text.split('\n');
  const title = lines.find(l => l.startsWith('PLAN:'))?.replace('PLAN:', '').trim()
    || 'Untitled Plan';

  const steps: ExecutionPlan['steps'] = [];
  let stepId = 0;

  for (const line of lines) {
    const match = line.match(/^\d+\.\s*\[([A-Z]+)\]\s*(.+?)(?:\s+-\s+(.+))?$/);
    if (match) {
      steps.push({
        id: `step-${stepId++}`,
        description: match[2].trim(),
        tool: match[1].toLowerCase(),
        input: match[3] ? { path: match[3].trim() } : undefined,
        status: 'pending'
      });
    }
  }

  return {
    id: `plan-${Date.now()}`,
    title,
    originalPrompt,
    steps,
    createdAt: new Date(),
    updatedAt: new Date()
  };
}

// å±•ç¤ºè®¡åˆ’
function displayPlan(plan: ExecutionPlan): void {
  console.log(chalk.cyan('\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
  console.log(chalk.cyan(`â•‘  ğŸ“‹ ${plan.title.padEnd(55)}â•‘`));
  console.log(chalk.cyan('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n'));

  console.log(chalk.bold('Steps:'));
  plan.steps.forEach((step, i) => {
    const icon = {
      read: 'ğŸ“–',
      write: 'âœï¸',
      edit: 'ğŸ”§',
      bash: 'âš¡',
      explain: 'ğŸ’¡'
    }[step.tool] || 'â€¢';

    const status = step.status === 'done' ? chalk.green(' âœ“') :
                   step.status === 'skipped' ? chalk.yellow(' âŠ˜') :
                   step.status === 'failed' ? chalk.red(' âœ—') : '';

    console.log(`  ${i + 1}. ${icon} ${step.description}${status}`);
    if (step.input?.path) {
      console.log(chalk.dim(`     Target: ${step.input.path}`));
    }
  });

  const progress = plan.steps.filter(s => s.status === 'done').length;
  console.log(chalk.dim(`\nProgress: ${progress}/${plan.steps.length} completed\n`));
}

// æ‰§è¡Œè®¡åˆ’
async function executePlan(
  plan: ExecutionPlan,
  options: KodaXOptions
): Promise<void> {
  console.log(chalk.cyan('\nğŸ“‹ Executing plan...\n'));

  const pendingSteps = plan.steps.filter(s => s.status === 'pending');

  for (const step of pendingSteps) {
    console.log(chalk.dim(`\n[Step ${plan.steps.indexOf(step) + 1}/${plan.steps.length}]`));
    console.log(`${step.description}`);

    const shouldExecute = await confirm('Execute this step?');

    if (!shouldExecute) {
      step.status = 'skipped';
      await planStorage.save(plan);
      continue;
    }

    try {
      // æ‰§è¡Œæ­¥éª¤
      const result = await runKodaX({
        ...options,
        beforeToolExecute: async (tool, input) => {
          console.log(chalk.dim(`  Using tool: ${tool}`));
          return true;
        }
      }, `Execute this step: ${step.description}`);

      step.status = 'done';
      step.executedAt = new Date();
      await planStorage.save(plan);

      console.log(chalk.green('  âœ“ Done'));

    } catch (error) {
      step.status = 'failed';
      await planStorage.save(plan);
      console.log(chalk.red(`  âœ— Failed: ${error}`));

      const continuePlan = await confirm('Continue with next step?');
      if (!continuePlan) break;
    }
  }

  console.log(chalk.cyan('\nğŸ“‹ Plan execution completed\n'));
}

// ä¸»å…¥å£
export async function runWithPlanMode(
  prompt: string,
  options: KodaXOptions
): Promise<void> {
  // 1. æ£€æŸ¥æœªå®Œæˆè®¡åˆ’
  const pending = await planStorage.findPending();
  if (pending) {
    const progress = pending.steps.filter(s => s.status === 'done').length;
    const resume = await confirm(
      `ğŸ“‹ Found pending plan: ${pending.title}\n` +
      `Progress: ${progress}/${pending.steps.length}\n` +
      `Resume?`
    );

    if (resume) {
      displayPlan(pending);
      return executePlan(pending, options);
    }
  }

  // 2. ç”Ÿæˆæ–°è®¡åˆ’
  console.log(chalk.dim('\nğŸ“ Generating plan...\n'));
  const planText = await generatePlan(prompt, options);
  const plan = parsePlanText(planText, prompt);

  // 3. ä¿å­˜è®¡åˆ’
  await planStorage.save(plan);

  // 4. å±•ç¤ºå¹¶ç¡®è®¤
  displayPlan(plan);
  const confirmed = await confirm('Execute this plan?');

  if (!confirmed) {
    console.log(chalk.dim('\nPlan saved. Use /plan resume to continue.\n'));
    return;
  }

  // 5. æ‰§è¡Œ
  await executePlan(plan, options);
}

// åˆ—å‡ºæ‰€æœ‰è®¡åˆ’
export async function listPlans(): Promise<void> {
  const plans = await planStorage.list();

  if (plans.length === 0) {
    console.log(chalk.dim('No saved plans'));
    return;
  }

  console.log(chalk.cyan('\nğŸ“‹ Saved Plans:\n'));
  plans.forEach(p => {
    const progress = p.steps.filter(s => s.status === 'done').length;
    const status = progress === p.steps.length ? chalk.green('completed') :
                   progress > 0 ? chalk.yellow('in progress') : chalk.dim('pending');
    console.log(`  ${p.id.slice(0, 8)} - ${p.title} (${progress}/${p.steps.length}) [${status}]`);
  });
  console.log();
}

// æ¢å¤æŒ‡å®šè®¡åˆ’
export async function resumePlan(planId: string, options: KodaXOptions): Promise<void> {
  const plan = await planStorage.load(planId);
  if (!plan) {
    console.log(chalk.red('Plan not found'));
    return;
  }

  displayPlan(plan);
  await executePlan(plan, options);
}

// æ¸…é™¤å·²å®Œæˆè®¡åˆ’
export async function clearCompletedPlans(): Promise<void> {
  const plans = await planStorage.list();
  const completed = plans.filter(p =>
    p.steps.every(s => s.status === 'done' || s.status === 'skipped')
  );

  for (const p of completed) {
    await planStorage.delete(p.id);
  }

  console.log(chalk.dim(`Cleared ${completed.length} completed plans`));
}
```

#### 4.3.3 REPL å‘½ä»¤

**æ–‡ä»¶**: `src/interactive/commands.ts`

```typescript
import { runWithPlanMode, listPlans, resumePlan, clearCompletedPlans } from '../cli/plan-mode.js';

{
  name: 'plan',
  aliases: ['p'],
  description: 'Plan mode management',
  usage: '/plan [on|off|once|list|resume|clear] [args]',
  handler: async (args, context, callbacks, config) => {
    const subCommand = args[0]?.toLowerCase();

    switch (subCommand) {
      case 'on':
        context.planMode = true;
        console.log(chalk.cyan('[Plan mode enabled]'));
        break;

      case 'off':
        context.planMode = false;
        console.log(chalk.cyan('[Plan mode disabled]'));
        break;

      case 'once': {
        // å•æ¬¡ä½¿ç”¨ plan mode
        const prompt = args.slice(1).join(' ');
        if (!prompt) {
          console.log(chalk.yellow('Usage: /plan once <your request>'));
          return;
        }
        const options = createKodaXOptions(config);
        await runWithPlanMode(prompt, options);
        break;
      }

      case 'list':
        await listPlans();
        break;

      case 'resume': {
        const planId = args[1];
        if (!planId) {
          console.log(chalk.yellow('Usage: /plan resume <plan-id>'));
          return;
        }
        const options = createKodaXOptions(config);
        await resumePlan(planId, options);
        break;
      }

      case 'clear':
        await clearCompletedPlans();
        break;

      default:
        console.log(chalk.dim('Usage: /plan [on|off|once|list|resume|clear]'));
        console.log(chalk.dim(`Current: ${context.planMode ? 'enabled' : 'disabled'}`));
    }
  }
}
```

---

## 5. å®ç°è®¡åˆ’

### é˜¶æ®µä¸€ï¼šCore å±‚ï¼ˆP0ï¼‰

| ä»»åŠ¡ | æ–‡ä»¶ | æ”¹åŠ¨ |
|------|------|------|
| 1 | `src/kodax_core.ts` | `KodaXToolExecutionContext` æ–°å¢ `beforeToolExecute` é’©å­ |
| 2 | `src/kodax_core.ts` | `executeTool` å‡½æ•°è°ƒç”¨é’©å­ |

**é¢„è®¡ä»£ç é‡**ï¼š~10 è¡Œ

### é˜¶æ®µäºŒï¼šCLI å±‚ï¼ˆP0ï¼‰

| ä»»åŠ¡ | æ–‡ä»¶ | æ”¹åŠ¨ |
|------|------|------|
| 3 | `src/cli/plan-storage.ts` | æ–°å¢ï¼šè®¡åˆ’å­˜å‚¨å®ç° |
| 4 | `src/cli/plan-mode.ts` | æ–°å¢ï¼šPlan Mode ä¸»é€»è¾‘ |
| 5 | `src/interactive/commands.ts` | æ–°å¢ `/plan` å‘½ä»¤ |

**é¢„è®¡ä»£ç é‡**ï¼š~300 è¡Œ

### é˜¶æ®µä¸‰ï¼šæµ‹è¯•ä¸ä¼˜åŒ–ï¼ˆP1ï¼‰

| ä»»åŠ¡ | æè¿° |
|------|------|
| 6 | å•å…ƒæµ‹è¯•ï¼šè®¡åˆ’è§£æ |
| 7 | å•å…ƒæµ‹è¯•ï¼šè®¡åˆ’å­˜å‚¨ |
| 8 | é›†æˆæµ‹è¯•ï¼šå®Œæ•´æµç¨‹ |

---

## 6. å…³é”®å†³ç­–æ€»ç»“

| å†³ç­– | é€‰æ‹© | ç†ç”± |
|------|------|------|
| JSON vs æ–‡æœ¬è®¡åˆ’ | **æ–‡æœ¬** | é¿å… AI JSON ä¸å¯é é—®é¢˜ |
| Core vs CLI å®ç° | **CLI** | ä¿æŒ Core æç®€ï¼ŒCLI çµæ´» |
| æŒä¹…åŒ– | **æ”¯æŒ** | ä¸­æ–­æ¢å¤æ˜¯æ ¸å¿ƒä»·å€¼ |
| æ­¥éª¤çº§ç¡®è®¤ | **æ”¯æŒ** | é€šè¿‡ `beforeToolExecute` é’©å­ |

---

## 7. ä¸ Claude Code çš„å¯¹æ¯”

| åŠŸèƒ½ | Claude Code | KodaX (æœ¬æ–¹æ¡ˆ) |
|------|-------------|----------------|
| Plan Mode è§¦å‘ | `/plan` | `/plan` å‘½ä»¤ |
| è®¡åˆ’å±•ç¤º | ç»“æ„åŒ–åˆ—è¡¨ | æ–‡æœ¬åˆ—è¡¨ |
| æ­¥éª¤é€‰æ‹© | æ”¯æŒ | æ‰§è¡Œå‰ç¡®è®¤ |
| ä¸­æ–­æ¢å¤ | æ”¯æŒ | **æ”¯æŒï¼ˆè®¡åˆ’æŒä¹…åŒ–ï¼‰** |
| è®¡åˆ’æŒä¹…åŒ– | ä¸æ”¯æŒ | **æ”¯æŒ** |
| Core å±‚å¤æ‚åº¦ | é«˜ | **æç®€ï¼ˆ1 ä¸ªé’©å­ï¼‰** |

---

## 8. äº¤äº’ç¤ºä¾‹

### REPL ä½¿ç”¨

```
> /plan once
> æ·»åŠ ç”¨æˆ·è®¤è¯

ğŸ“ Generating plan...

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ğŸ“‹ Add User Authentication                                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Steps:
  1. ğŸ“– Check current project structure - .
  2. ğŸ“– Check dependencies - package.json
  3. âœï¸  Create auth middleware - src/middleware/auth.ts
  4. âœï¸  Create auth routes - src/routes/auth.ts
  5. ğŸ”§ Add auth routes - src/app.ts

Progress: 0/5 completed

Execute this plan? (y/n) y

ğŸ“‹ Executing plan...

[Step 1/5]
Check current project structure
Execute this step? (y/n) y
  Using tool: read
  âœ“ Done

[Step 2/5]
Check dependencies
Execute this step? (y/n) y
  Using tool: read
  âœ“ Done

[Step 3/5]
Create auth middleware
Execute this step? (y/n) y
  Using tool: write
[User æŒ‰ä¸‹ Ctrl+C]

Session interrupted. Plan saved.

> /plan list
ID        Title                    Progress  Status
abc123    Add User Authentication  2/5       in progress

> /plan resume abc123
Resuming plan: Add User Authentication

Steps:
  1. ğŸ“– Check current project structure âœ“
  2. ğŸ“– Check dependencies âœ“
  3. âœï¸  Create auth middleware
  4. âœï¸  Create auth routes
  5. ğŸ”§ Add auth routes

[Step 3/5]
Create auth middleware
Execute this step? (y/n) y
...
```

---

## 9. é£é™©ä¸å›æ»š

| é£é™© | å¯èƒ½æ€§ | åº”å¯¹æªæ–½ |
|------|--------|----------|
| è®¡åˆ’è§£æä¸å‡†ç¡® | ä¸­ | ä¼˜åŒ–æç¤ºè¯ï¼Œä¿æŒè§£æé€»è¾‘ç®€å• |
| è®¡åˆ’æ–‡ä»¶æŸå | ä½ | try-catchï¼ŒæŸåæ—¶é‡æ–°ç”Ÿæˆ |
| ä¸ç°æœ‰åŠŸèƒ½å†²çª | ä½ | å®Œå–„çš„æµ‹è¯•è¦†ç›– |

**å›æ»šæ–¹æ¡ˆ**ï¼š
- Core å±‚é’©å­ä¸ºå¯é€‰ï¼Œä¸å½±å“ç°æœ‰åŠŸèƒ½
- åˆ é™¤ CLI å±‚ Plan Mode ç›¸å…³æ–‡ä»¶å³å¯å®Œå…¨ç¦ç”¨
