# v0.5.0 Feature Design

_创建时间: 2026-02-25_
_更新时间: 2026-02-27_

**版本**: v0.5.0
**状态**: Planned
**Feature 数量**: 4

---

## FEATURE_006: Agent Skills 系统

### 1. 概述

实现完整的 [Agent Skills](https://agentskills.io/) 开放标准，使 KodaX 能够：
- 加载和使用符合 Agent Skills 标准的技能
- 完全兼容 Claude Code 及其他支持 Agent Skills 的工具开发的 skills
- 支持渐进式披露机制，优化上下文使用
- 提供企业级的技能管理和分发能力

**参考文档**:
- [Agent Skills 官方标准](https://agentskills.io/)
- [Claude Code Skills 文档](https://code.claude.com/docs/en/skills)
- [The Complete Guide to Building Skills for Claude](https://resources.anthropic.com/hubfs/The-Complete-Guide-to-Building-Skill-for-Claude.pdf)

### 2. 影响范围

**需要创建的文件**:
```
packages/repl/src/skills/
├── index.ts                    # 技能系统入口
├── types.ts                    # 类型定义 (符合 Agent Skills 标准)
├── skill-loader.ts             # 技能加载器
├── skill-registry.ts           # 技能注册表
├── skill-resolver.ts           # 技能解析器 (参数替换、动态上下文)
├── discovery.ts                # 技能发现与扫描
├── executor.ts                 # 技能执行器 (支持 fork 模式)
└── builtin/                    # 内置技能目录
    ├── code-review/
    │   └── SKILL.md
    ├── git-workflow/
    │   └── SKILL.md
    └── tdd/
        └── SKILL.md
```

**需要修改的文件**:
- `packages/repl/src/interactive/commands.ts` - 集成 `/skills` 命令
- `packages/repl/src/ui/InkREPL.tsx` - 技能 UI 反馈
- `packages/repl/src/llm/context-builder.ts` - 渐进式披露集成

### 3. 技术方案

#### 3.0 依赖说明

| 依赖 | 用途 | 说明 |
|------|------|------|
| `gray-matter` | YAML frontmatter 解析 | 支持容错解析，处理非标准 YAML 格式 |

#### 3.1 Agent Skills 标准文件结构

每个 Skill 是一个目录，包含以下结构：

```
skill-name/
├── SKILL.md           # 必需 - 主技能文件
├── scripts/           # 可选 - 可执行脚本
│   ├── analyze.py
│   └── validate.sh
├── templates/         # 可选 - 模板文件
│   └── output.md
└── resources/         # 可选 - 参考文档
    └── style-guide.md
```

**YAML Frontmatter 解析**:
```typescript
import matter from 'gray-matter';

// 容错解析：处理非标准 YAML（如未引用的含冒号字符串）
function fallbackSanitization(content: string): string {
  // 将含冒号的值转换为 block scalar 格式
  // 例如: description: This: contains: colons
  // 转换为: description: |-
  //           This: contains: colons
}

async function parseSkill(filePath: string) {
  const template = await readFile(filePath);
  try {
    return matter(template);
  } catch {
    // 容错：尝试 sanitization 后重新解析
    return matter(fallbackSanitization(template));
  }
}
```

#### 3.2 SKILL.md 格式

```markdown
---
# === 必需字段 ===
name: skill-name
description: 技能描述。包含触发条件，例如"当用户要求...时使用"。

# === Claude Code 扩展字段 (可选) ===
disable-model-invocation: false    # 是否禁止自动触发
user-invocable: true               # 是否在 / 菜单显示
allowed-tools: "Read, Grep, Glob"  # 限制可用工具
context: fork                      # 在子代理中执行
agent: Explore                     # 指定子代理类型
argument-hint: "[file] [format]"   # 参数提示
model: haiku                       # 指定模型

# === 元数据 (可选) ===
license: MIT
compatibility: "Requires Python 3.8+"
metadata:
  author: KodaX Team
  version: 1.0.0
  tags: [code-quality, review]
---

# Skill Title

技能的详细指令内容...

## 使用方式

处理 $ARGUMENTS 的任务...

或按位置访问参数:
- 第一个参数: $0
- 第二个参数: $1

## 动态上下文

当前 git 状态:
!`git status --short`

## 参考资源

详见 [resources/style-guide.md](resources/style-guide.md)
```

#### 3.3 渐进式披露 (Progressive Disclosure)

**第一级 - 元数据预加载**:
```typescript
// 启动时，仅加载 name 和 description 到系统提示
interface SkillMetadata {
  name: string;
  description: string;
  userInvocable: boolean;
  argumentHint?: string;
}
```

**第二级 - 完整内容加载**:
```typescript
// 当技能被触发时，加载完整 SKILL.md
interface SkillContent extends SkillMetadata {
  content: string;           // Markdown 正文
  disableModelInvocation: boolean;
  allowedTools?: string[];
  context?: 'fork';
  agent?: string;
  model?: string;
}
```

**第三级 - 支持文件按需加载**:
```typescript
// 仅在需要时加载 scripts/, templates/, resources/
interface SkillResources {
  scripts: Map<string, string>;
  templates: Map<string, string>;
  resources: Map<string, string>;
}
```

#### 3.4 技能发现机制

```typescript
// 技能扫描路径优先级
const SKILL_PATHS = [
  // 1. 企业级 (最高优先级)
  '~/.kodax/skills/enterprise/',

  // 2. 用户级
  '~/.kodax/skills/',

  // 3. 项目级
  '${projectRoot}/.kodax/skills/',

  // 4. 插件级
  '${pluginPath}/skills/',

  // 5. 内置
  '${kodaxRoot}/builtin/skills/',
];

// 嵌套目录自动发现 (支持 monorepo)
// 当用户在 packages/frontend/ 工作时，自动扫描:
// - packages/frontend/.kodax/skills/
// - packages/.kodax/skills/
// - .kodax/skills/
```

### 4. 接口契约

#### 4.1 核心类型定义

```typescript
/**
 * Agent Skills 标准类型定义
 * 符合 https://agentskills.io/ 规范
 */

// === YAML Frontmatter 字段 ===

interface SkillFrontmatter {
  // 必需字段
  name: string;                          // kebab-case, 最大 64 字符
  description: string;                   // 最大 1024 字符，包含触发条件

  // Claude Code 扩展字段
  disableModelInvocation?: boolean;      // 默认 false
  userInvocable?: boolean;               // 默认 true
  allowedTools?: string;                 // 工具限制，如 "Read, Grep, Bash(python:*)"
  context?: 'fork';                      // 子代理执行模式
  agent?: string;                        // 子代理类型: Explore, Plan, general-purpose 等
  argumentHint?: string;                 // 参数提示，如 "[file] [format]"
  model?: 'haiku' | 'sonnet' | 'opus';   // 指定模型

  // 元数据
  license?: string;
  compatibility?: string;
  metadata?: Record<string, unknown>;
}

// === 完整 Skill 定义 ===

interface Skill extends SkillFrontmatter {
  // 文件路径
  path: string;                          // Skill 目录绝对路径
  skillFilePath: string;                 // SKILL.md 绝对路径

  // 内容
  content: string;                       // Markdown 正文 (已处理变量替换)

  // 支持文件
  scripts?: SkillFile[];                 // scripts/ 目录文件
  templates?: SkillFile[];               // templates/ 目录文件
  resources?: SkillFile[];               // resources/ 目录文件

  // 运行时状态
  loaded: boolean;                       // 是否已完整加载
  source: 'enterprise' | 'user' | 'project' | 'plugin' | 'builtin';
}

interface SkillFile {
  name: string;                          // 文件名
  path: string;                          // 绝对路径
  relativePath: string;                  // 相对于 Skill 目录的路径
  content?: string;                      // 文件内容 (按需加载)
}

// === 技能注册表 ===

interface SkillRegistry {
  // 所有已发现的技能元数据
  skills: Map<string, SkillMetadata>;

  // 发现技能
  discover(): Promise<void>;

  // 获取技能
  get(name: string): Promise<Skill | undefined>;

  // 加载完整技能内容
  loadFull(name: string): Promise<Skill>;

  // 触发技能
  invoke(name: string, args: string, context: SkillContext): Promise<SkillResult>;
}

// === 技能执行上下文 ===

interface SkillContext {
  workingDirectory: string;
  messages: Message[];
  sessionId: string;
  environment: Record<string, string>;
}

// === 技能执行结果 ===

interface SkillResult {
  success: boolean;
  content: string;                       // 处理后的提示内容
  artifacts?: SkillArtifact[];           // 生成的文件等
  error?: string;
}
```

#### 4.2 变量替换系统

```typescript
/**
 * 技能内容变量替换
 */
interface VariableResolver {
  // 替换所有变量
  resolve(content: string, args: string, context: SkillContext): string;
}

// 支持的变量:
// $ARGUMENTS     - 所有参数
// $0, $1, $2...  - 按位置访问参数
// ${CLAUDE_SESSION_ID} - 会话 ID
// !`command`     - 动态上下文注入 (预处理执行)

// 示例:
// 输入: "审查 $ARGUMENTS 的代码"
// 参数: "src/auth.ts"
// 输出: "审查 src/auth.ts 的代码"

// 动态上下文示例:
// 输入: "当前状态:\n!`git status --short`"
// 执行: git status --short
// 输出: "当前状态:\nM src/auth.ts\n?? src/new.ts"
```

#### 4.3 命令接口

```typescript
// /skills - 列出所有可用技能
// /skill-name [args...] - 调用技能
// /skills reload - 重新扫描技能目录
// /skills info <name> - 显示技能详情
```

### 5. 实现步骤

#### Phase 1: 核心框架

1. **创建类型定义** `types.ts`
   - 定义符合 Agent Skills 标准的接口
   - 支持 Claude Code 扩展字段

2. **实现技能发现** `discovery.ts`
   - 多路径扫描
   - 嵌套目录支持
   - 优先级处理

3. **实现技能加载器** `skill-loader.ts`
   - YAML frontmatter 解析 (使用 **gray-matter** 库)
   - 容错处理：支持非标准 YAML 格式（参考 OpenCode 的 `fallbackSanitization`）
   - Markdown 内容处理
   - 支持文件加载

**依赖**: `gray-matter` - 成熟的 YAML frontmatter 解析库，支持容错解析

#### Phase 2: 执行引擎

4. **实现变量解析器** `skill-resolver.ts`
   - `$ARGUMENTS` 替换
   - `$0`, `$1` 位置参数
   - `` !`command` `` 动态上下文
   - `${CLAUDE_SESSION_ID}` 环境变量

5. **实现技能注册表** `skill-registry.ts`
   - 渐进式披露
   - 技能缓存
   - 热重载

6. **实现执行器** `executor.ts`
   - 内联执行
   - `context: fork` 子代理执行
   - 工具权限控制

#### Phase 3: 集成与 UI

7. **集成命令系统** `commands.ts`
   - `/skills` 命令
   - `/skill-name` 调用
   - Tab 补全

8. **UI 反馈** `InkREPL.tsx`
   - 技能加载状态
   - 执行进度
   - 结果展示

#### Phase 4: 内置技能与测试

9. **创建内置技能** `builtin/`
   - `code-review/SKILL.md`
   - `git-workflow/SKILL.md`
   - `tdd/SKILL.md`

10. **兼容性测试**
    - 测试 Claude Code 官方 skills
    - 测试社区 skills
    - 边界情况处理

### 6. 兼容性保证

#### 6.1 Claude Code Skills 兼容

```typescript
// 完全兼容 Claude Code 的 skills 格式
// 支持 Claude Code 的所有扩展字段:
// - disable-model-invocation
// - user-invocable
// - allowed-tools
// - context: fork
// - agent
// - argument-hint
// - model
// - hooks

// 路径兼容:
// - ~/.claude/skills/
// - .claude/skills/
```

#### 6.2 Agent Skills 标准兼容

```typescript
// 遵循 agentskills.io 标准
// - SKILL.md 文件格式
// - YAML frontmatter 必需字段
// - 渐进式披露机制
// - 可移植性
```

### 7. 验收标准

- [x] **标准兼容**
  - [x] 完全解析 Agent Skills 标准 SKILL.md
  - [x] 支持 YAML frontmatter 所有标准字段
  - [x] 支持渐进式披露机制

- [x] **Claude Code 兼容**
  - [x] 加载 `~/.claude/skills/` 目录
  - [x] 加载 `.claude/skills/` 目录
  - [x] 支持 Claude Code 扩展字段
  - [ ] 测试通过 3 个以上 Claude Code 官方 skills (待人工测试)

- [x] **功能完整**
  - [x] `/skills` 命令列出所有技能
  - [x] `/skill-name [args]` 调用技能
  - [x] `$ARGUMENTS` 参数替换
  - [x] `$0`, `$1` 位置参数
  - [x] `` !`command` `` 动态上下文
  - [x] `scripts/`, `templates/`, `resources/` 支持

- [ ] **高级特性** (Phase 2)
  - [ ] `context: fork` 子代理执行
  - [ ] `allowed-tools` 工具限制
  - [x] 嵌套目录自动发现
  - [ ] 热重载 (placeholder 实现)

- [x] **内置技能**
  - [x] 至少 3 个内置技能
  - [x] 每个技能包含完整文档

### 8. 示例：完整 Skill

```
code-review/
├── SKILL.md
├── scripts/
│   └── complexity.py
├── templates/
│   └── review-report.md
└── resources/
    └── coding-standards.md
```

**SKILL.md**:
```markdown
---
name: code-review
description: 代码审查技能。当用户要求审查代码、code review、检查代码质量、review code 时使用。
disable-model-invocation: false
user-invocable: true
allowed-tools: "Read, Grep, Glob, Bash(python:*)"
argument-hint: "[file-or-directory]"
---

# Code Review Skill

对 **$ARGUMENTS** 进行全面的代码审查。

## 审查流程

1. **读取目标文件**
   使用 Read 工具读取 $ARGUMENTS 指定的文件或目录。

2. **分析代码复杂度**
   运行复杂度分析脚本:
   ```bash
   python scripts/complexity.py $ARGUMENTS
   ```

3. **检查编码规范**
   参考 [resources/coding-standards.md](resources/coding-standards.md)

4. **生成审查报告**
   使用 [templates/review-report.md](templates/review-report.md) 格式

## 当前 Git 状态

!`git diff --stat HEAD~5`

## 审查重点

- 代码风格一致性
- 潜在安全漏洞
- 性能问题
- 可维护性
- 测试覆盖
```

### 9. 实现记录 (2026-02-28)

**实现状态**: ✅ 核心功能完成

**已创建文件**:
- `packages/repl/src/skills/types.ts` - Agent Skills 标准类型定义
- `packages/repl/src/skills/skill-loader.ts` - YAML frontmatter 解析 (自定义实现，无 gray-matter 依赖)
- `packages/repl/src/skills/discovery.ts` - 多路径技能扫描
- `packages/repl/src/skills/skill-resolver.ts` - 变量替换系统
- `packages/repl/src/skills/skill-registry.ts` - 渐进式披露注册表
- `packages/repl/src/skills/executor.ts` - 技能执行引擎
- `packages/repl/src/skills/index.ts` - 模块入口
- `packages/repl/src/skills/__tests__/skills.test.ts` - 单元测试 (15 tests)
- `packages/repl/src/skills/builtin/code-review/SKILL.md` - 代码审查技能
- `packages/repl/src/skills/builtin/git-workflow/SKILL.md` - Git 工作流技能
- `packages/repl/src/skills/builtin/tdd/SKILL.md` - TDD 技能

**已修改文件**:
- `packages/repl/src/interactive/commands.ts` - 集成 `/skills` 命令

**技术决策**:
1. **不使用 gray-matter 依赖**: 实现了自定义 YAML 解析器，支持:
   - 容错处理非标准 YAML (如含冒号的未引用字符串)
   - 行尾符规范化 (CRLF/LF)
   - BOM 处理

2. **渐进式披露实现**:
   - 第一级: `SkillMetadata` (name, description, userInvocable, argumentHint)
   - 第二级: `Skill` 完整内容
   - 第三级: 按需加载 scripts/templates/resources

3. **变量替换系统**:
   - `$ARGUMENTS` - 所有参数
   - `$0`, `$1`, `$2`... - 位置参数
   - `${CLAUDE_SESSION_ID}` - 会话环境变量
   - `` !`command` `` - 动态上下文注入

**测试覆盖**: 15 个测试用例全部通过
- parseSkillMarkdown 解析测试
- 必需字段验证
- 布尔字段处理
- 参数解析
- 变量替换
- 技能发现
- 注册表操作

---

## FEATURE_007: 主题系统完善

### 1. 概述

将所有硬编码的 chalk 颜色改为使用主题系统，实现全局主题切换。

### 2. 影响范围

**需要修改的文件**:
- `packages/repl/src/interactive/commands.ts` - 使用主题颜色
- `packages/repl/src/interactive/project-commands.ts` - 使用主题颜色
- `packages/repl/src/ui/themes/index.ts` - 添加主题切换
- `packages/repl/src/ui/contexts/` - 添加 ThemeContext

### 3. 技术方案

**ThemeContext**:
```typescript
interface ThemeContextValue {
  theme: Theme;
  setTheme: (name: string) => void;
  themeColors: ThemeColors;
}
```

**命令颜色迁移**:
```typescript
// 之前
console.log(chalk.cyan('消息'));

// 之后
console.log(chalk.hex(theme.colors.primary)('消息'));
```

### 4. 接口契约

**新增命令**:
- `/theme` - 显示当前主题
- `/theme <name>` - 切换主题
- `/theme list` - 列出所有可用主题

### 5. 实现步骤

1. **创建 ThemeContext**
2. **修改命令系统注入主题**
3. **迁移 commands.ts 的 chalk 调用**
4. **迁移 project-commands.ts 的 chalk 调用**
5. **添加 /theme 命令**
6. **主题配置持久化**

### 6. 验收标准

- [ ] `/theme` 命令可用
- [ ] 命令输出颜色随主题变化
- [ ] 主题选择持久化
- [ ] dark 和 minimal 主题都正常工作

---

## FEATURE_008: 权限控制体系改进

### 1. 概述

完善 KodaX 权限控制系统，对标 Claude Code 的权限控制方案，提供更细粒度的权限管理。

**对标文档**:
- [Claude Code Settings](https://code.claude.com/docs/en/settings)

### 2. 现有机制分析

#### 2.1 KodaX 现有能力

| 功能 | 实现位置 | 说明 |
|------|----------|------|
| 工具确认机制 | `registry.ts:80` | `bash`, `write`, `edit` 默认需确认 |
| auto 模式 | `kodax_cli.ts` | `-y/--auto` 跳过确认 |
| 项目外操作保护 | `registry.ts:239-256` | 即使 auto 模式也保护 |
| 危险命令检测 | `registry.ts:153-216` | 检测 `rm`, `mv`, `cp` 等 |
| code/ask 模式 | `commands.ts:151-228` | 读写 vs 只读模式切换 |

#### 2.2 与 Claude Code 的差距

| 维度 | KodaX | Claude Code |
|------|-------|-------------|
| 权限模式数量 | 2种 (code/ask) | 3种 (default/accept-edits/plan) |
| 命令模式匹配 | ❌ 不支持 | ✅ `Bash(git log:*)` |
| 沙盒模式 | ❌ 不支持 | ✅ `/sandbox` |
| 项目外保护 | ✅ 内置 | ⚠️ 需配置 |
| 危险命令检测 | ✅ 内置 | ❌ 无 |

### 3. 影响范围

**需要修改的文件**:

```
packages/core/src/
├── types.ts                           # 新增 PermissionMode 类型，扩展 KodaXOptions
├── tools/
│   ├── registry.ts                    # 修改执行逻辑，集成模式判断和永久保护
│   └── permission.ts                  # 新增：computeConfirmTools, isAlwaysConfirmPath

packages/repl/src/
├── interactive/
│   ├── commands.ts                    # 修改 /mode 命令支持四级模式
│   └── project-commands.ts            # 修改 projectAuto 自动切换权限模式
├── ui/
│   └── components/
│       └── ConfirmPrompt.tsx          # 新增：确认提示组件（支持 y/Y/n）
├── common/
│   └── permission-config.ts           # 新增：权限配置管理（加载/保存配置）

src/
├── kodax_cli.ts                       # 新增 --mode 参数，修改 createKodaXOptions
└── cli-permission.ts                  # 新增：CLI 权限处理逻辑
```

**需要创建的文件**:
```
packages/core/src/tools/permission.ts             # 权限计算函数
packages/repl/src/common/permission-config.ts     # 配置管理
packages/repl/src/ui/components/ConfirmPrompt.tsx # 确认提示组件
src/cli-permission.ts                             # CLI 权限处理
```

**配置文件变更**:
```
~/.kodax/config.json                   # 用户级配置（已存在，需扩展 permission 字段）
项目根目录/.kodax/config.local.json    # 项目级配置（新建）
```

### 4. 技术方案

#### 4.1 四级权限模式

```typescript
// types.ts

/**
 * 权限模式
 * - plan: 只读规划，禁止所有修改操作
 * - default: 全部需要确认
 * - accept-edits: 文件自动，命令需确认
 * - auto-in-project: 项目内全自动，项目外需确认
 */
type PermissionMode = 'plan' | 'default' | 'accept-edits' | 'auto-in-project';

/**
 * 权限模式条目（用于项目级配置）
 */
interface PermissionPatternEntry {
  pattern: string;          // 模式字符串，如 "Bash(rm -rf dist:*)"
  description?: string;     // 模式描述
  addedAt: string;          // 添加时间 (ISO 8601)
  addedBy: 'user-confirm' | 'manual';  // 添加来源
}

/**
 * 用户级权限配置
 */
interface UserPermissionConfig {
  mode: PermissionMode;
  allowedPatterns: string[];      // 简单字符串数组
  deniedPatterns: string[];
}

/**
 * 项目级权限配置
 */
interface ProjectPermissionConfig {
  mode: PermissionMode;
  allowedPatterns: PermissionPatternEntry[];  // 详细条目数组
  deniedPatterns: PermissionPatternEntry[];
}

/**
 * 完整配置文件格式
 */
interface KodaXConfig {
  $schema?: string;
  version: string;                // 配置版本，当前为 "1.0.0"
  permission: UserPermissionConfig | ProjectPermissionConfig;
}
```

**模式行为**:

| 模式 | 文件编辑 | Shell 命令 | 危险命令 | 项目外操作 | 说明 |
|------|----------|------------|----------|------------|------|
| `plan` | 禁止 | 禁止 | 禁止 | 禁止 | **只读规划** |
| `default` | 需确认 | 需确认 | 需确认 | 需确认 | 安全默认 |
| `accept-edits` | 自动 | 需确认 | 需确认 | 需确认 | 日常开发 |
| `auto-in-project` | 自动 | 自动 | 自动* | 需确认 | **项目内全自动** |

> **注**: `auto-in-project` 模式下，**项目内**的 `rm -rf` 等危险命令也会自动执行。
> 这是设计意图——用户明确信任项目内操作。但项目外的任何操作都需要确认。

**危险命令定义** (在 `registry.ts` 中):
```typescript
const DANGEROUS_COMMANDS = [
  'rm ', 'rm -', 'rmdir', 'mv ', 'cp ', 'del ', 'rd ',
  'shred', 'wipe', 'chmod', 'chown',
  '>', '>>', '2>',  // 重定向操作
];
```

#### 4.2 命令模式匹配

允许用户配置细粒度的命令权限控制：

```typescript
// permission-matcher.ts

/**
 * 命令模式匹配器
 *
 * 模式语法:
 * - 'Read'              - 匹配 Read 工具
 * - 'Write'             - 匹配 Write 工具
 * - 'Bash(git log:*)'   - 匹配 git log 开头的命令
 * - 'Bash(npm:*)'       - 匹配 npm 开头的命令
 * - 'Bash(rm:*)'        - 匹配 rm 开头的命令
 * - 'Bash(*:*)'         - 匹配所有 Bash 命令
 */
export class PermissionMatcher {
  private compiledPatterns: Map<string, RegExp> = new Map();

  constructor(patterns: string[]) {
    for (const pattern of patterns) {
      this.compiledPatterns.set(pattern, this.compile(pattern));
    }
  }

  /**
   * 检查工具调用是否匹配任一模式
   */
  matches(toolName: string, input: Record<string, unknown>): boolean {
    for (const [pattern, regex] of this.compiledPatterns) {
      if (this.matchPattern(pattern, regex, toolName, input)) {
        return true;
      }
    }
    return false;
  }

  /**
   * 编译模式字符串为正则表达式
   */
  private compile(pattern: string): RegExp {
    // 'Bash(git log:*)' → /^git log/
    // 'Bash(npm:*)' → /^npm/
    const match = pattern.match(/^(\w+)\(([^:]+):\*\)$/);
    if (match) {
      const [, _tool, cmd] = match;
      return new RegExp(`^${this.escapeRegex(cmd!)}`);
    }
    // 简单工具名匹配
    return new RegExp(`^${this.escapeRegex(pattern)}$`);
  }

  private escapeRegex(str: string): string {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }
}
```

**在 registry.ts 中的集成**:
```typescript
// 执行工具前的权限检查
async function executeTool(name: string, input: unknown, ctx: KodaXToolExecutionContext) {
  // 1. 检查永久保护区域
  if (isAlwaysConfirmPath(input)) {
    return confirmExecution(name, input, { hideAlwaysOption: true });
  }

  // 2. 检查模式级别权限
  const mode = getPermissionMode();
  if (mode === 'plan' && MODIFICATION_TOOLS.has(name)) {
    return '[Blocked] Modifications not allowed in plan mode';
  }

  // 3. 检查 allowedPatterns
  const matcher = getPermissionMatcher();
  if (matcher.matches(name, input)) {
    return executeDirectly(name, input);
  }

  // 4. 根据模式决定是否需要确认
  if (shouldAutoApprove(mode, name, input)) {
    return executeDirectly(name, input);
  }

  // 5. 需要确认
  return confirmExecution(name, input, { hideAlwaysOption: false });
}
```

#### 4.3 配置层次结构

**两级配置，项目级优先**:

```
~/.kodax/config.json              # 用户级默认配置
└── 项目根目录/.kodax/config.local.json  # 项目级配置（覆盖用户级）
```

**⚠️ 永久保护区域（任何模式下都需确认）**:

```typescript
// 这些操作永远需要确认，不受任何配置影响
const ALWAYS_CONFIRM_PATHS = [
  '.kodax/',           // 项目配置目录
  '~/.kodax/',         // 用户配置目录
];

// 任何 "yes always" 或 allowedPatterns 配置对这些路径无效
function isAlwaysConfirmPath(path: string): boolean {
  return ALWAYS_CONFIRM_PATHS.some(p => path.includes(p));
}
```

**配置文件格式**:

**用户级配置** (`~/.kodax/config.json`):
```json
{
  "permission": {
    "mode": "default",
    "allowedPatterns": [
      "Bash(git status:*)",
      "Bash(git log:*)",
      "Bash(npm test:*)"
    ],
    "deniedPatterns": [
      "Bash(rm -rf /*:*)",
      "Bash(sudo:*)"
    ]
  }
}
```

**项目级配置** (`.kodax/config.local.json`):
```json
{
  "$schema": "./node_modules/@kodax/schema/config.local.schema.json",
  "version": "1.0.0",
  "permission": {
    "mode": "accept-edits",
    "allowedPatterns": [
      {
        "pattern": "Bash(rm -rf dist:*)",
        "description": "允许清理 dist 目录",
        "addedAt": "2026-02-26T20:30:00Z",
        "addedBy": "user-confirm"
      },
      {
        "pattern": "Bash(npm:*)",
        "description": "允许所有 npm 命令",
        "addedAt": "2026-02-26T20:30:00Z",
        "addedBy": "user-confirm"
      }
    ],
    "deniedPatterns": []
  }
}
```

**配置字段说明**:

| 字段 | 类型 | 说明 |
|------|------|------|
| `$schema` | string | JSON Schema 引用（可选，用于 IDE 提示） |
| `version` | string | 配置文件版本，当前为 `"1.0.0"` |
| `permission.mode` | string | 权限模式 |
| `permission.allowedPatterns` | array | 允许的模式列表 |
| `permission.deniedPatterns` | array | 禁止的模式列表 |
| `pattern` | string | 模式字符串 |
| `description` | string | 模式描述（可选） |
| `addedAt` | string | 添加时间（ISO 8601） |
| `addedBy` | string | 添加来源：`user-confirm` / `manual` |

**配置加载优先级**:
1. 项目级 `.kodax/config.local.json` (最高优先级)
2. 用户级 `~/.kodax/config.json`
3. 代码内置默认值

#### 4.4 确认提示增强

在需要确认操作时，提供三个选项：

```
⚠️  Allow Bash: rm -rf dist/ ?

  [y] Yes (this time only)
  [Y] Yes always (only for this project)
  [n] No

> _
```

**⚠️ 永久保护规则（不显示 Yes always 选项）**:

当操作涉及以下路径时，**不显示 `[Y] Yes always` 选项**：
- `.kodax/` 目录内的任何操作
- 项目目录外的任何操作
- `~/.kodax/` 目录内的任何操作

```
⚠️  Allow Write: .kodax/config.local.json ?

  [y] Yes (this time only)
  [n] No
  (This path always requires confirmation)

> _
```

**持久化逻辑**:

```typescript
async function handleConfirmChoice(
  choice: 'y' | 'Y' | 'n',
  operation: { tool: string; input: Record<string, unknown> }
): Promise<void> {

  if (choice === 'n') return;

  if (choice === 'Y') {
    const currentMode = getPermissionMode();

    if (currentMode === 'default') {
      // default 模式下选 Yes always → 自动切换到 accept-edits 模式
      await setPermissionMode('accept-edits');
    }

    // 如果是 bash 命令，加入配置
    if (operation.tool === 'bash') {
      const pattern = generatePattern(operation.input);
      await addAllowedPattern(pattern, {
        description: `Allowed via user confirmation`,
        addedBy: 'user-confirm'
      });
    }
  }
}
```

**模式切换行为**:

| 当前模式 | 用户选择 | 结果 |
|----------|----------|------|
| `default` | `[y]` | 本次允许，模式不变 |
| `default` | `[Y]` | **自动切换到 `accept-edits`** + 保存 bash 命令到配置 |
| `accept-edits` | `[y]` | 本次允许，模式不变 |
| `accept-edits` | `[Y]` | 保存 bash 命令到配置 |
| `auto-in-project` | - | 项目内不显示确认提示 |
| `plan` | - | 禁止所有修改操作 |

#### 4.5 UI 组件变更

**确认提示组件** (`ConfirmPrompt.tsx`):

```tsx
import React, { useState } from 'react';
import { Box, Text } from 'ink';

interface ConfirmPromptProps {
  toolName: string;
  input: Record<string, unknown>;
  hideAlwaysOption: boolean;  // 永久保护区域时为 true
  onConfirm: (choice: 'y' | 'Y' | 'n') => void;
}

export const ConfirmPrompt: React.FC<ConfirmPromptProps> = ({
  toolName,
  input,
  hideAlwaysOption,
  onConfirm
}) => {
  return (
    <Box flexDirection="column">
      <Box>
        <Text color="yellow">⚠️  Allow {toolName}: {formatInput(input)} ?</Text>
      </Box>
      <Box flexDirection="column" marginLeft={2}>
        <Text>[y] Yes (this time only)</Text>
        {!hideAlwaysOption && (
          <Text>[Y] Yes always (only for this project)</Text>
        )}
        <Text>[n] No</Text>
      </Box>
    </Box>
  );
};
```

**状态栏模式显示** (修改 `StatusBar.tsx`):

```tsx
// 在状态栏中显示当前权限模式
const MODE_COLORS = {
  'plan': 'gray',
  'default': 'yellow',
  'accept-edits': 'green',
  'auto-in-project': 'cyan'
};

<Text color={MODE_COLORS[mode]}>
  Mode: {mode}
</Text>
```

### 5. 接口契约

#### 5.1 模式切换命令

```bash
/mode                           # 显示当前模式
/mode plan                      # 只读规划模式
/mode default                   # 默认模式（全部确认）
/mode accept-edits              # 接受编辑模式（文件自动，命令需确认）
/mode auto-in-project           # 项目内全自动模式
```

#### 5.2 配置文件

**用户级配置** (`~/.kodax/config.json`):
```json
{
  "permission": {
    "mode": "default",
    "allowedPatterns": [
      "Bash(git status:*)",
      "Bash(git log:*)",
      "Bash(npm test:*)"
    ],
    "deniedPatterns": [
      "Bash(rm -rf /*:*)",
      "Bash(sudo:*)"
    ]
  }
}
```

**项目级配置** (`.kodax/config.local.json`):
```json
{
  "$schema": "./node_modules/@kodax/schema/config.local.schema.json",
  "version": "1.0.0",
  "permission": {
    "mode": "accept-edits",
    "allowedPatterns": [
      {
        "pattern": "Bash(rm -rf dist:*)",
        "description": "允许清理 dist 目录",
        "addedAt": "2026-02-26T20:30:00Z",
        "addedBy": "user-confirm"
      }
    ]
  }
}
```

> **⚠️ 保护规则**: `.kodax/` 目录和项目外操作永远需要确认，不受配置影响。

### 6. 实现步骤

#### Phase 1: 核心框架

1. **权限类型定义**
   - 添加 `PermissionMode`, `PermissionConfig` 类型
   - 文件修改：`packages/core/src/types.ts`

2. **实现 PermissionMatcher**
   - 创建 `packages/core/src/tools/permission-matcher.ts`
   - 支持命令模式匹配 (如 `Bash(git log:*)`)

3. **配置管理**
   - 创建 `packages/repl/src/common/permission-config.ts`
   - 支持用户级 (`~/.kodax/`) 和项目级 (`.kodax/`) 配置
   - 项目级配置优先

#### Phase 2: 模式系统

4. **四级模式实现**
   - 修改 `commands.ts` 支持 `/mode plan|default|accept-edits|auto-in-project`
   - 更新 UI 状态显示当前模式

5. **模式行为实现**
   - `plan`: 禁止 write/edit/bash
   - `default`: 全部需确认
   - `accept-edits`: 文件自动，命令需确认
   - `auto-in-project`: 项目内全自动，项目外需确认

#### Phase 3: 确认增强

6. **确认提示增强**
   - 修改确认 UI 支持三个选项: `y/Y/n`
   - `Y` (Yes always) 持久化到 `.kodax/config.local.json`

7. **持久化逻辑**
   - 根据操作类型生成模式字符串
   - 写入项目级配置文件

### 7. 验收标准

- [ ] **四级模式**
  - [ ] `/mode plan` 禁止所有修改操作
  - [ ] `/mode default` 全部需要确认
  - [ ] `/mode accept-edits` 文件自动，命令需确认
  - [ ] `/mode auto-in-project` 项目内全自动
  - [ ] 状态栏显示当前模式

- [ ] **auto-in-project 模式行为**
  - [ ] 项目内 `write`/`edit` 自动执行
  - [ ] 项目内 `bash` 命令自动执行（包括危险命令）
  - [ ] 项目外任何操作都需确认
  - [ ] 危险命令在项目内自动执行但有日志记录

- [ ] **命令模式匹配**
  - [ ] `Bash(git log:*)` 匹配成功
  - [ ] `Bash(rm:*)` 匹配成功
  - [ ] 通配符 `*` 正常工作
  - [ ] 允许列表中的命令跳过确认

- [ ] **配置管理**
  - [ ] 用户级配置 `~/.kodax/config.json` 正常加载
  - [ ] 项目级配置 `.kodax/config.local.json` 正常加载
  - [ ] 项目级配置优先于用户级配置
  - [ ] 配置重启后保持

- [ ] **确认提示增强**
  - [ ] `[y]` 仅本次允许
  - [ ] `[Y]` 允许并持久化（仅 `accept-edits` 模式生效）
  - [ ] `[n]` 拒绝操作
  - [ ] `default` 模式下选 `[Y]` 自动切换到 `accept-edits` 模式
  - [ ] Bash 命令的 `[Y]` 选择写入 `.kodax/config.local.json`
  - [ ] 持久化的模式正确保存和加载

- [ ] **永久保护区域**
  - [ ] `.kodax/` 目录操作永远需要确认
  - [ ] `~/.kodax/` 目录操作永远需要确认
  - [ ] 项目外操作永远需要确认
  - [ ] 永久保护区域不显示 `[Y] Yes always` 选项
  - [ ] 永久保护区域不受 `allowedPatterns` 配置影响

- [ ] **CLI 集成**
  - [ ] `--mode plan|default|accept-edits|auto-in-project` 参数正常工作
  - [ ] `--auto-continue` 自动使用 `auto-in-project` 模式
  - [ ] 无 `--mode` 时从配置文件加载模式
  - [ ] 旧 `--auto` 参数映射到 `auto-in-project`

- [ ] **REPL /project 集成**
  - [ ] `/project auto` 自动切换到 `auto-in-project` 模式
  - [ ] `/project auto` 退出后恢复原模式
  - [ ] `/project next` 使用当前权限模式
  - [ ] `/project auto --confirm` 每个特性仍需用户确认（但工具操作使用 auto-in-project）

- [ ] **向后兼容**
  - [ ] `/mode code` 映射到 `accept-edits` 并显示提示
  - [ ] `/mode ask` 映射到 `plan` 并显示提示
  - [ ] 旧的 `confirmTools` 设置仍然有效
  - [ ] 无 `permissionMode` 时使用 `confirmTools` 推断模式

### 8. 兼容性

- 现有 `/mode code|ask` 命令兼容：
  - `/mode ask` → `/mode plan`
  - `/mode code` → `/mode accept-edits`
- 新增模式不影响现有配置文件
- CLI 使用 `--mode` 参数统一管理四种模式

### 8.1 项目模式权限映射

**CLI 和 REPL 的"项目模式"自动使用 `auto-in-project` 权限**：

| 场景 | 命令 | 权限模式 |
|------|------|----------|
| CLI 快速模式 | `kodax --mode auto-in-project` | `auto-in-project` |
| CLI 项目自动执行 | `kodax --auto-continue` | `auto-in-project` |
| REPL 项目自动执行 | `/project auto` | `auto-in-project` |

**实现逻辑**：

```typescript
// CLI: --auto-continue 自动启用 auto-in-project
if (options.autoContinue) {
  permissionConfig.mode = 'auto-in-project';
}

// REPL: /project auto 自动启用 auto-in-project
async function projectAuto(...) {
  // 进入项目自动执行时，切换权限模式
  await setPermissionMode('auto-in-project');
  // ... 执行项目特性
}
```

**设计理由**：
- 项目模式（`/project auto` 或 `--auto-continue`）意味着用户已明确信任该项目
- 此场景下项目内操作应全自动执行，无需反复确认
- 但项目外操作、`.kodax/` 目录仍需确认（永久保护规则）

### 8.2 现有代码集成设计

#### 8.2.1 现有机制分析

**当前权限控制实现**（`packages/core/src/agent.ts:80`）：

```typescript
// 当前实现
confirmTools: options.confirmTools ?? new Set(['bash', 'write', 'edit']),
```

**当前检查逻辑**（`packages/core/src/tools/registry.ts:259`）：

```typescript
if (ctx.confirmTools.has(name) && !ctx.auto) {
  // 需要确认
}
```

**当前 CLI 参数映射**（`src/kodax_cli.ts:195`）：

```typescript
confirmTools: cliOptions.auto
  ? new Set()           // --auto: 空 set，全部自动
  : new Set(['bash', 'write', 'edit']),  // 默认：这些工具需确认
```

#### 8.2.2 新旧机制映射

| 新模式 | confirmTools 值 | auto 标志 | 说明 |
|--------|-----------------|-----------|------|
| `plan` | 所有修改工具 | - | 阻止执行，不只是确认 |
| `default` | `['bash', 'write', 'edit']` | false | 当前默认行为 |
| `accept-edits` | `['bash']` | false | 只有 bash 需确认 |
| `auto-in-project` | `[]` | true | 空集 + 项目外保护 |

#### 8.2.3 类型定义扩展

```typescript
// packages/core/src/types.ts

// 新增：权限模式类型
export type PermissionMode = 'plan' | 'default' | 'accept-edits' | 'auto-in-project';

// 扩展 KodaXOptions
export interface KodaXOptions {
  // ... 现有字段
  permissionMode?: PermissionMode;  // 新增：统一权限模式
  confirmTools?: Set<string>;       // 保留：向后兼容
  auto?: boolean;                   // 保留：向后兼容
}

// 扩展 KodaXToolExecutionContext
export interface KodaXToolExecutionContext {
  // ... 现有字段
  permissionMode: PermissionMode;   // 新增
  projectRoot: string;              // 新增：用于判断项目内外
}
```

#### 8.2.4 权限计算函数

```typescript
// packages/core/src/tools/permission.ts

/**
 * 根据权限模式计算 confirmTools
 */
export function computeConfirmTools(mode: PermissionMode): Set<string> {
  switch (mode) {
    case 'plan':
      // plan 模式：所有修改工具都需要"确认"（实际上是阻止）
      return new Set(['bash', 'write', 'edit', 'undo']);
    case 'default':
      // 默认：当前行为
      return new Set(['bash', 'write', 'edit']);
    case 'accept-edits':
      // 接受编辑：只有 bash 需确认
      return new Set(['bash']);
    case 'auto-in-project':
      // 项目内全自动：空集（项目外保护在执行时检查）
      return new Set();
  }
}

/**
 * 判断是否为永久保护路径
 */
export function isAlwaysConfirmPath(targetPath: string, projectRoot: string): boolean {
  const normalizedPath = path.resolve(targetPath);

  // .kodax/ 目录
  if (normalizedPath.includes(path.join(projectRoot, '.kodax'))) {
    return true;
  }

  // ~/.kodax/ 目录
  if (normalizedPath.includes(path.join(os.homedir(), '.kodax'))) {
    return true;
  }

  // 项目外
  if (!normalizedPath.startsWith(projectRoot)) {
    return true;
  }

  return false;
}
```

#### 8.2.5 CLI 集成（修改 `src/kodax_cli.ts`）

```typescript
// 新增 --mode 参数
.option('--mode <mode>', 'Permission mode: plan|default|accept-edits|auto-in-project')

// 修改 createKodaXOptions
function createKodaXOptions(cliOptions: CliOptions, isPrintMode = false): KodaXOptions {
  // 确定 permissionMode
  let permissionMode: PermissionMode;
  if (cliOptions.mode) {
    // --mode 显式指定
    permissionMode = cliOptions.mode as PermissionMode;
  } else if (cliOptions.autoContinue || cliOptions.auto) {
    // --auto-continue 或 --auto → auto-in-project
    permissionMode = 'auto-in-project';
  } else {
    // 从配置文件加载或默认 default
    permissionMode = loadPermissionMode() ?? 'default';
  }

  return {
    provider: cliOptions.provider,
    thinking: cliOptions.thinking,
    maxIter: cliOptions.maxIter,
    parallel: cliOptions.parallel,
    permissionMode,
    confirmTools: computeConfirmTools(permissionMode),
    auto: permissionMode === 'auto-in-project',
    session: buildSessionOptions(cliOptions),
    events: createCliEvents(!isPrintMode),
  };
}
```

#### 8.2.6 REPL 集成（修改 `packages/repl/src/interactive/commands.ts`）

```typescript
// 修改 /mode 命令支持 4 种模式
{
  name: 'mode',
  aliases: ['m'],
  description: 'Switch permission mode',
  usage: '/mode [plan|default|accept-edits|auto-in-project]',
  handler: async (args, _context, callbacks, currentConfig) => {
    if (args.length === 0) {
      console.log(chalk.dim(`\nCurrent mode: ${chalk.cyan(currentConfig.permissionMode ?? 'default')}`));
      console.log(chalk.dim('Usage: /mode [plan|default|accept-edits|auto-in-project]'));
      return;
    }

    const newMode = args[0] as PermissionMode;
    const validModes: PermissionMode[] = ['plan', 'default', 'accept-edits', 'auto-in-project'];

    if (validModes.includes(newMode)) {
      currentConfig.permissionMode = newMode;
      // 更新 KodaXOptions 中的权限设置
      callbacks.updatePermissionMode?.(newMode);
      console.log(chalk.green(`\n✓ Mode switched to: ${newMode}`));
    } else {
      console.log(chalk.red(`\n[Unknown mode: ${args[0]}]`));
      console.log(chalk.dim(`Valid modes: ${validModes.join(', ')}`));
    }
  },
}
```

#### 8.2.7 /project auto 集成（修改 `packages/repl/src/interactive/project-commands.ts`）

```typescript
async function projectAuto(
  args: string[],
  context: InteractiveContext,
  callbacks: CommandCallbacks,
  _currentConfig: CurrentConfig,
  confirm: (message: string) => Promise<boolean>,
  question: (prompt: string) => Promise<string>
): Promise<void> {
  // ... 现有检查代码 ...

  // 进入 auto 模式前，切换权限
  const previousMode = _currentConfig.permissionMode;
  _currentConfig.permissionMode = 'auto-in-project';
  callbacks.updatePermissionMode?.('auto-in-project');

  console.log(chalk.cyan('\nAuto-Continue Mode'));
  console.log(chalk.dim(`  Permission mode: auto-in-project (project operations auto-approved)`));
  // ... 其余代码 ...

  // 退出时恢复原模式
  finally {
    projectRuntimeState.setAutoContinueRunning(false);
    _currentConfig.permissionMode = previousMode;
    callbacks.updatePermissionMode?.(previousMode);
  }
}
```

#### 8.2.8 registry.ts 执行逻辑修改

```typescript
// packages/core/src/tools/registry.ts

async function executeTool(name: string, input: unknown, ctx: KodaXToolExecutionContext) {
  // 1. plan 模式：阻止修改操作
  if (ctx.permissionMode === 'plan' && MODIFICATION_TOOLS.has(name)) {
    return {
      success: false,
      error: `[Blocked] Tool '${name}' not allowed in plan mode`,
    };
  }

  // 2. 永久保护路径检查
  const targetPath = extractPathFromInput(name, input);
  if (targetPath && isAlwaysConfirmPath(targetPath, ctx.projectRoot)) {
    // 永久保护区域：强制确认，不显示 Yes always 选项
    const confirmed = await confirmExecution(name, input, { hideAlwaysOption: true });
    if (!confirmed) {
      return { success: false, error: '[Rejected] Operation on protected path' };
    }
  }

  // 3. 常规 confirmTools 检查
  if (ctx.confirmTools.has(name) && !ctx.auto) {
    const confirmed = await confirmExecution(name, input, { hideAlwaysOption: false });
    if (!confirmed) {
      return { success: false, error: '[Rejected] User declined' };
    }
  }

  // 4. 执行工具
  return executeToolInternal(name, input, ctx);
}
```

#### 8.2.9 向后兼容性

```typescript
// 向后兼容：旧的 code/ask 模式映射
const LEGACY_MODE_MAP: Record<string, PermissionMode> = {
  'code': 'accept-edits',
  'ask': 'plan',
};

// 在处理 /mode 命令时
if (args[0] === 'code' || args[0] === 'ask') {
  const mappedMode = LEGACY_MODE_MAP[args[0]];
  console.log(chalk.dim(`Note: '/mode ${args[0]}' is deprecated, use '/mode ${mappedMode}' instead`));
  // 继续使用映射后的模式
}
```

### 9. 模式选择建议

| 场景 | 推荐模式 | 理由 |
|------|----------|------|
| 首次审查代码库 | `plan` | 只读，安全探索 |
| 熟悉项目的小改动 | `accept-edits` | 文件编辑快捷，命令有保护 |
| **深度开发（推荐）** | `auto-in-project` | 项目内全自动化，效率最高 |
| 生产环境/重要项目 | `default` | 最大程度保护 |

### 10. 代码位置索引

| 功能 | 文件 | 行号 |
|------|------|------|
| 默认确认工具 | `packages/core/src/tools/registry.ts` | L80 |
| 项目外保护 | `packages/core/src/tools/registry.ts` | L239-256 |
| 危险命令检测 | `packages/core/src/tools/registry.ts` | L153-216 |
| 路径检查 | `packages/core/src/tools/registry.ts` | L135-147 |
| 模式类型定义 | `packages/core/src/types.ts` | L148, L187 |
| CLI 参数 | `src/kodax_cli.ts` | L163-183 |
| 交互命令 | `packages/repl/src/interactive/commands.ts` | L151-228 |

### 11. 实际实现状态 (v0.4.6)

> **实现时间**: 2026-02-27
> **提交**: 7ea393b, 86a89bd

#### 11.1 简化的 Pattern 匹配

实际实现比设计更简洁，**只对 Bash 工具支持 pattern 匹配**：

```typescript
// Pattern 格式（仅 Bash 工具，仅在 accept-edits 模式）
// - "Bash(npm install)"   - 精确匹配
// - "Bash(git commit:*)"  - 前缀通配符
// - "Bash(npm:*)"         - 命令前缀通配符
// - "Bash(*)"             - ❌ 被拒绝，太危险
```

**关键决策**：
- `alwaysAllowTools` pattern **只在 accept-edits 模式下对 bash 生效**
- `plan` 和 `default` 模式**不使用** `alwaysAllowTools`
- 其他工具不需要 pattern：
  - Read/Glob/Grep: 项目内自动允许，项目外强制询问
  - Edit/Write: accept-edits 模式自动，default 模式强制询问

#### 11.2 模式行为对照表

| 模式 | Edit/Write | Bash | alwaysAllowTools |
|------|------------|------|------------------|
| `plan` | 禁止 | 禁止 | ❌ 不生效 |
| `default` | 强制询问 | 强制询问 | ❌ 不生效 |
| `accept-edits` | 自动允许 | 需确认，可用 pattern 跳过 | ✅ 仅 Bash |
| `auto-in-project` | 自动允许 | 自动允许 | ❌ 不生效 |

#### 11.3 核心代码

```typescript
// packages/core/src/tools/permission.ts

// Pattern 解析
export function parseAllowedToolPattern(entry: string): { tool: string; pattern: string | null }

// Pattern 匹配（仅 Bash）
export function isToolCallAllowed(toolName: string, input: Record<string, unknown>, allowedPatterns: string[]): boolean

// 生成保存 Pattern（拒绝 Bash(*)）
export function generateSavePattern(toolName: string, input: Record<string, unknown>, allowAll: boolean): string

// 权限模式计算
export function computeConfirmTools(mode: PermissionMode): Set<string>
```

```typescript
// packages/core/src/tools/registry.ts

// 只在 accept-edits 模式下检查 alwaysAllowTools（仅 bash）
if (mode === 'accept-edits' && name === 'bash') {
  if (isToolCallAllowed(name, input, ctx.alwaysAllowTools)) {
    skipConfirmation = true;
  }
}
```

#### 11.4 配置文件格式

```json
// .kodax/config.local.json
{
  "permissionMode": "accept-edits",
  "alwaysAllowTools": [
    "Bash(npm install)",
    "Bash(npm run:*)",
    "Bash(git commit:*)"
  ]
}
```

---

## 10. CLI 模式设计

### 10.1 CLI 参数

简化设计，仅需一个参数：

```bash
kodax [prompt] [options]

权限模式选项:
  --mode <mode>              权限模式: plan | default | accept-edits | auto-in-project
```

**参数行为**:

| CLI 参数 | 效果 |
|----------|------|
| 无 `--mode` | 从配置文件加载，配置文件也没有则 `default` |
| `--mode plan` | 只读规划模式 |
| `--mode default` | 全部需确认 |
| `--mode accept-edits` | 文件自动，命令需确认 |
| `--mode auto-in-project` | 项目内全自动 |
| `--auto-continue` | 自动使用 `auto-in-project`（项目自动执行） |

> **注**：`--auto-continue` 是项目自动执行场景，自动启用 `auto-in-project` 权限。

### 10.2 配置加载

配置文件位置固定，无需指定：

```typescript
// src/kodax_cli.ts

async function loadPermissionConfig(options: CLIOptions): Promise<PermissionConfig> {
  // 1. 加载用户级配置（固定路径）
  const userConfig = await loadUserConfig();  // ~/.kodax/config.json

  // 2. 加载项目级配置（固定路径，如果存在）
  const projectConfig = await loadProjectConfig();  // 项目根目录/.kodax/config.local.json

  // 3. CLI --mode 参数优先，否则用配置文件，最后用默认值
  const mode = options.mode
    || projectConfig?.permission?.mode
    || userConfig?.permission?.mode
    || 'default';

  // 4. 合并 allowedPatterns
  const allowedPatterns = [
    ...(userConfig?.permission?.allowedPatterns || []),
    ...(projectConfig?.permission?.allowedPatterns || []).map(e => e.pattern),
  ];

  const deniedPatterns = [
    ...(userConfig?.permission?.deniedPatterns || []),
    ...(projectConfig?.permission?.deniedPatterns || []).map(e => e.pattern),
  ];

  return { mode, allowedPatterns, deniedPatterns };
}
```

### 10.3 CLI 确认提示

```typescript
async function confirmInCLI(
  toolName: string,
  input: unknown,
  options: { hideAlwaysOption: boolean }
): Promise<'y' | 'Y' | 'n'> {

  // 非交互式终端时直接拒绝
  if (!process.stdin.isTTY) {
    console.error('[Blocked] Operation requires confirmation but running in non-interactive mode');
    return 'n';
  }

  console.log(`\n⚠️  Allow ${toolName}: ${formatInput(input)} ?`);
  console.log('  [y] Yes (this time only)');
  if (!options.hideAlwaysOption) {
    console.log('  [Y] Yes always (only for this project)');
  }
  console.log('  [n] No');

  const answer = await promptInput('> ');
  return parseAnswer(answer, options.hideAlwaysOption);
}
```

### 10.4 CLI 与 REPL 差异

| 特性 | CLI 模式 | REPL 模式 |
|------|----------|-----------|
| 模式切换 | `--mode` 参数 | `/mode` 命令 |
| 配置文件 | 固定路径 | 固定路径 |
| 持久化 | 写入 `.kodax/config.local.json` | 写入 `.kodax/config.local.json` |
| 确认 UI | stdin/stdout | Ink React 组件 |
| 非交互式 | 需确认的操作被拒绝 | 不适用 |

### 10.5 CLI 需要修改的文件

```
src/
├── kodax_cli.ts              # 添加 --mode 参数
└── cli-permission.ts         # 新增：CLI 权限处理逻辑

packages/core/src/tools/
└── registry.ts               # 添加 CLI 确认逻辑分支
```

### 10.6 CLI 使用示例

```bash
# 只读规划模式
kodax "分析项目结构" --mode plan

# 默认模式（从配置加载或使用 default）
kodax "修复 bug in auth.ts"

# 日常开发模式
kodax "添加登录功能" --mode accept-edits

# 项目内全自动模式
kodax "重构所有组件" --mode auto-in-project

# 项目自动执行（自动启用 auto-in-project）
kodax --auto-continue

# CI/CD 场景：指定全自动模式避免交互
kodax "build and test" --mode auto-in-project
```

---

## FEATURE_009: 架构重构

> **Feature ID**: Architecture Refactor
> **Priority**: High
> **Status**: Planning
> **Created**: 2026-02-27
> **Inspired by**: [pi-mono](https://github.com/badlogic/pi-mono)

### 1. 背景

#### 1.1 当前架构问题

```
KodaX 当前架构:
├── @kodax/core
│   ├── providers/     ← LLM 抽象（混合在 core 中）
│   ├── tools/
│   │   ├── registry.ts    ← 工具执行 + 权限检查（混合）
│   │   └── permission.ts  ← 权限逻辑（不应在 core）
│   └── agent.ts       ← Agent 主循环
├── @kodax/repl
│   └── UI + 权限配置
└── kodax (CLI)
```

**问题**:
1. **Core 职责不清**: 混入了 UI 关注点（权限确认、提示）
2. **AI 层不独立**: providers 捆绑在 core 中，无法单独复用
3. **CLI 过于复杂**: 支持模式切换，与快速执行的目标冲突

#### 1.2 pi-mono 的启发

pi-mono 在 Terminal-Bench 基准测试中表现优异，其核心理念：

```
pi-mono 四层架构:
┌─────────────────────────────────────┐
│        pi-coding-agent              │  ← CLI 工具层
├─────────────────────────────────────┤
│           pi-tui                    │  ← 终端 UI 层
├─────────────────────────────────────┤
│        pi-agent-core                │  ← Agent 逻辑层（纯执行）
├─────────────────────────────────────┤
│           pi-ai                     │  ← LLM 抽象层（独立包）
└─────────────────────────────────────┘
```

**关键设计决策**:
- **4 个工具**: read, write, edit, bash
- **YOLO 模式**: 默认无权限检查，快速执行
- **AI 独立**: `pi-ai` 作为独立包，可复用
- **极简系统提示**: < 1000 tokens

### 2. 目标架构

#### 2.1 新的四层架构

```
┌─────────────────────────────────────────────────────────────┐
│                    kodax (CLI 入口)                          │
│              默认 auto 模式，快速执行                          │
├─────────────────────────────────────────────────────────────┤
│                   @kodax/repl                                │
│           终端 UI + 权限控制 + 模式管理                         │
│     (权限只在这里有意义，CLI 不使用权限层)                       │
├─────────────────────────────────────────────────────────────┤
│                   @kodax/core                                │
│         Agent 逻辑 + 工具执行（无权限检查）                      │
│              executeTool() 只管执行                           │
├─────────────────────────────────────────────────────────────┤
│                    @kodax/ai                                 │
│         LLM 抽象层（独立包，可复用）                            │
│   Anthropic, OpenAI, Google, xAI, Groq, Cerebras...          │
└─────────────────────────────────────────────────────────────┘
```

#### 2.2 各层职责

| 层 | 包名 | 职责 | 权限 |
|---|------|------|------|
| **CLI** | `kodax` | 命令行入口，默认 auto 模式 | 无权限检查 |
| **REPL** | `@kodax/repl` | 交互式 UI，权限管理 | 完整权限控制 |
| **Core** | `@kodax/core` | Agent 循环，工具执行 | 无权限逻辑 |
| **AI** | `@kodax/ai` | LLM 提供商抽象 | N/A |

#### 2.3 CLI vs REPL 的区别

| 特性 | CLI 模式 | REPL 模式 |
|------|---------|-----------|
| **默认权限** | auto (YOLO) | default (每次询问) |
| **模式切换** | ❌ 不支持 | ✅ 支持 |
| **权限配置** | ❌ 不读取 | ✅ 读取 |
| **适用场景** | 快速任务执行 | 交互式开发 |
| **用户体验** | 简洁快速 | 精细控制 |

### 3. @kodax/ai - LLM 抽象层

#### 3.1 设计目标

- **独立包**: 可被其他项目复用
- **统一 API**: 消除提供商差异
- **流式支持**: 所有提供商统一流式接口
- **成本跟踪**: Token 使用量统计

#### 3.2 目录结构

```
packages/ai/
├── src/
│   ├── index.ts           # 统一导出
│   ├── types.ts           # 统一类型定义
│   ├── base.ts            # 基类 Provider
│   ├── providers/
│   │   ├── anthropic.ts   # Anthropic Claude
│   │   ├── openai.ts      # OpenAI GPT
│   │   ├── google.ts      # Google Gemini
│   │   ├── xai.ts         # xAI Grok
│   │   ├── groq.ts        # Groq
│   │   ├── cerebras.ts    # Cerebras
│   │   └── openrouter.ts  # OpenRouter 代理
│   ├── utils/
│   │   ├── context-switch.ts  # 跨提供商上下文切换
│   │   ├── cost-tracker.ts    # 成本跟踪
│   │   └── quirks.ts          # 提供商差异处理
│   └── registry.ts        # Provider 注册表
└── package.json
```

#### 3.3 统一 API

```typescript
// types.ts

export interface AIProvider {
  name: string;
  isConfigured(): boolean;
  stream(messages: Message[], tools: Tool[], options: StreamOptions): Promise<StreamResult>;
}

export interface StreamOptions {
  systemPrompt?: string;
  thinking?: boolean;
  signal?: AbortSignal;
  onTextDelta?: (text: string) => void;
  onThinkingDelta?: (text: string) => void;
  onToolInputDelta?: (tool: string, json: string) => void;
}

export interface StreamResult {
  textBlocks: TextBlock[];
  toolBlocks: ToolBlock[];
  thinkingBlocks: ThinkingBlock[];
  usage?: UsageInfo;
}
```

#### 3.4 提供商差异处理

```typescript
// utils/quirks.ts

export const PROVIDER_QUIRKS = {
  cerebras: {
    disallowedFields: ['store'],
  },
  mistral: {
    tokenField: 'max_tokens',  // 而非 max_completion_tokens
    disallowedFields: ['store', 'developer'],
  },
  grok: {
    disallowedFields: ['reasoning_effort'],
  },
  openai: {
    // OpenAI 特殊处理
  },
  anthropic: {
    // Anthropic thinking block 支持
  },
};
```

#### 3.5 使用示例

```typescript
import { getProvider, listProviders } from '@kodax/ai';

// 获取提供商
const provider = getProvider('anthropic');

// 检查配置
if (!provider.isConfigured()) {
  throw new Error('Please set ANTHROPIC_API_KEY');
}

// 流式调用
const result = await provider.stream(messages, tools, {
  systemPrompt: 'You are a coding assistant.',
  thinking: true,
  onTextDelta: (text) => process.stdout.write(text),
});
```

### 4. @kodax/core - 纯 Agent 逻辑

#### 4.1 重构目标

- **移除权限**: `executeTool()` 不再检查权限
- **移除确认**: 不调用 `ctx.onConfirm`
- **纯粹执行**: 只管执行工具，返回结果

#### 4.2 重构前后对比

```typescript
// ===== 重构前 (当前) =====
// registry.ts

export async function executeTool(name: string, input: unknown, ctx: Context) {
  // 1. Plan mode check - 权限检查
  if (ctx.permissionMode === 'plan' && MODIFICATION_TOOLS.has(name)) {
    return { success: false, error: `[Blocked] Not allowed in plan mode` };
  }

  // 2. Protected path check - 权限检查
  if (isAlwaysConfirmPath(input.path, ctx.projectRoot)) {
    const confirmed = await ctx.onConfirm(name, input);  // UI 交互
    if (!confirmed) return { success: false, error: 'Rejected' };
  }

  // 3. Confirm tools check - 权限检查
  if (ctx.confirmTools.has(name)) {
    const confirmed = await ctx.onConfirm(name, input);  // UI 交互
    if (!confirmed) return { success: false, error: 'Rejected' };
  }

  // 4. 执行
  return executeInternal(name, input);
}


// ===== 重构后 =====
// registry.ts

export async function executeTool(name: string, input: unknown): Promise<ToolResult> {
  // 直接执行，无权限检查
  return executeInternal(name, input);
}
```

#### 4.3 移除的文件/代码

```
从 core 移除:
├── tools/permission.ts     → 移到 repl 层
├── registry.ts 中的权限检查 → 移到 repl 层
└── types.ts 中的权限类型   → 移到 repl 层
```

#### 4.4 简化后的 Context

```typescript
// 重构前
interface KodaXToolExecutionContext {
  permissionMode: PermissionMode;      // 移除
  confirmTools: Set<string>;           // 移除
  alwaysAllowTools: string[];          // 移除
  backups: Map<string, string>;        // 保留
  gitRoot?: string;                    // 保留
  onConfirm?: (...) => Promise<...>;   // 移除
  // ...
}

// 重构后
interface KodaXToolExecutionContext {
  backups: Map<string, string>;
  gitRoot?: string;
  // 仅保留必要的执行上下文
}
```

### 5. @kodax/repl - 权限层

#### 5.1 新增权限包装器

```typescript
// repl/src/permission-executor.ts

import { executeTool, type ToolResult } from '@kodax/core';

/**
 * 权限包装器 - 在调用 core 前检查权限
 */
export async function executeWithPermission(
  toolName: string,
  input: Record<string, unknown>,
  ctx: PermissionContext
): Promise<ToolResult> {
  const mode = ctx.permissionMode;

  // 1. Plan mode: 阻止所有修改
  if (mode === 'plan' && MODIFICATION_TOOLS.has(toolName)) {
    return { success: false, error: `[Blocked] Not allowed in plan mode` };
  }

  // 2. 项目外路径: 强制确认（所有模式）
  if (isExternalPath(input.path, ctx.projectRoot)) {
    const confirmed = await ctx.showConfirm(toolName, input);
    if (!confirmed) return { success: false, error: '[Rejected] External path' };
  }

  // 3. 模式判断
  const needsConfirm = shouldConfirm(toolName, mode, ctx);

  if (needsConfirm) {
    // 检查 alwaysAllowTools (仅在 accept-edits 模式)
    if (mode === 'accept-edits' && isToolCallAllowed(toolName, input, ctx.alwaysAllowTools)) {
      // 跳过确认
    } else {
      const result = await ctx.showConfirm(toolName, input);
      if (result === 'rejected') {
        return { success: false, error: '[Rejected] User declined' };
      }
      if (result === 'always') {
        ctx.saveAlwaysAllow(toolName, input);
      }
    }
  }

  // 4. 调用 core 执行
  return executeTool(toolName, input);
}

function shouldConfirm(tool: string, mode: PermissionMode, ctx: PermissionContext): boolean {
  switch (mode) {
    case 'plan':
      return true;  // 实际上 plan 模式会直接阻止
    case 'default':
      return ['bash', 'write', 'edit'].includes(tool);
    case 'accept-edits':
      return tool === 'bash';
    case 'auto-in-project':
      return false;  // 项目内全自动
  }
}
```

#### 5.2 权限配置加载

```typescript
// repl/src/permission-config.ts (保留)

// 从 .kodax/config.local.json 加载
// 从 ~/.kodax/config.json 加载
// 提供 loadPermissionMode(), loadAlwaysAllowTools() 等
```

### 6. CLI - YOLO 模式

#### 6.1 简化 CLI

```typescript
// src/kodax_cli.ts

async function runCli(prompt: string) {
  // CLI 默认 auto 模式，无权限检查
  const result = await runKodaX(
    {
      provider: 'anthropic',
      // 不传 permissionMode，CLI 不关心权限
      events: createCliEvents(),  // 简单事件处理
    },
    prompt
  );

  // 直接输出结果
  console.log(result.lastText);
}
```

#### 6.2 移除 CLI 参数

```bash
# 重构前
kodax --mode accept-edits "任务描述"
kodax --mode plan "任务描述"

# 重构后
kodax "任务描述"  # 直接执行，无模式切换
```

#### 6.3 如果用户需要权限控制

```bash
# 使用交互式 REPL
kodax --interactive

# REPL 中支持模式切换
/mode accept-edits
/mode plan
/mode default
```

### 7. 迁移计划

#### 7.1 阶段 1: 创建 @kodax/ai 包

1. 创建 `packages/ai/` 目录
2. 从 `core/providers/` 迁移代码
3. 统一 API 接口
4. 处理提供商差异
5. 发布独立包

#### 7.2 阶段 2: 重构 @kodax/core

1. 移除 `tools/permission.ts`
2. 简化 `registry.ts` 的 `executeTool()`
3. 简化 Context 类型
4. 更新 `agent.ts` 调用方式

#### 7.3 阶段 3: 更新 @kodax/repl

1. 创建 `permission-executor.ts`
2. 迁移权限逻辑
3. 更新 UI 组件调用

#### 7.4 阶段 4: 简化 CLI

1. 移除 `--mode` 参数
2. 默认 auto 模式
3. 简化事件处理

### 8. 风险与缓解

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| API 变更 | 现有用户代码可能失效 | 保持 `@kodax/core` 导出兼容 |
| 测试覆盖 | 重构可能引入 bug | 增加单元测试 |
| 文档更新 | 用户可能困惑 | 更新 README 和示例 |

### 9. 参考资源

- [pi-mono GitHub](https://github.com/badlogic/pi-mono)
- [pi-mono 设计文章](https://mp.weixin.qq.com/s/XRZrOvapXWiZneDtipfHTQ)
- [Terminal-Bench 基准测试](https://github.com/anthonycorletti/terminal-bench)

### 10. 决策记录

| 日期 | 决策 | 理由 |
|------|------|------|
| 2026-02-27 | 创建独立的 `@kodax/ai` 包 | 可复用，清晰的职责分离 |
| 2026-02-27 | 从 core 移除权限逻辑 | core 应该是纯执行，无 UI 关注点 |
| 2026-02-27 | CLI 默认 auto 模式 | CLI 用户目标是快速执行 |
| 2026-02-27 | 保留 REPL 权限控制 | 交互式开发需要精细控制 |
