# KodaX Architecture Refactor - 架构重构

> **Feature ID**: Architecture Refactor
> **Priority**: High
> **Status**: Planning
> **Created**: 2026-02-27
> **Inspired by**: [pi-mono](https://github.com/badlogic/pi-mono)

---

## 1. 背景

### 1.1 当前架构问题

```
KodaX 当前架构:
├── @kodax/core
│   ├── providers/     ← LLM 抽象（混合在 core 中）
│   ├── tools/
│   │   ├── registry.ts    ← 工具执行 + 权限检查（混合）
│   │   └── permission.ts  ← 权限逻辑（不应在 core）
│   └── agent.ts       ← Agent 主循环
├── @kodax/repl
│   └── UI + 权限配置
└── kodax (CLI)
```

**问题**:
1. **Core 职责不清**: 混入了 UI 关注点（权限确认、提示）
2. **AI 层不独立**: providers 捆绑在 core 中，无法单独复用
3. **CLI 过于复杂**: 支持模式切换，与快速执行的目标冲突

### 1.2 pi-mono 的启发

pi-mono 在 Terminal-Bench 基准测试中表现优异，其核心理念：

```
pi-mono 四层架构:
┌─────────────────────────────────────┐
│        pi-coding-agent              │  ← CLI 工具层
├─────────────────────────────────────┤
│           pi-tui                    │  ← 终端 UI 层
├─────────────────────────────────────┤
│        pi-agent-core                │  ← Agent 逻辑层（纯执行）
├─────────────────────────────────────┤
│           pi-ai                     │  ← LLM 抽象层（独立包）
└─────────────────────────────────────┘
```

**关键设计决策**:
- **4 个工具**: read, write, edit, bash
- **YOLO 模式**: 默认无权限检查，快速执行
- **AI 独立**: `pi-ai` 作为独立包，可复用
- **极简系统提示**: < 1000 tokens

---

## 2. 目标架构

### 2.1 新的四层架构

```
┌─────────────────────────────────────────────────────────────┐
│                    kodax (CLI 入口)                          │
│              默认 auto 模式，快速执行                          │
├─────────────────────────────────────────────────────────────┤
│                   @kodax/repl                                │
│           终端 UI + 权限控制 + 模式管理                         │
│     (权限只在这里有意义，CLI 不使用权限层)                       │
├─────────────────────────────────────────────────────────────┤
│                   @kodax/core                                │
│         Agent 逻辑 + 工具执行（无权限检查）                      │
│              executeTool() 只管执行                           │
├─────────────────────────────────────────────────────────────┤
│                    @kodax/ai                                 │
│         LLM 抽象层（独立包，可复用）                            │
│   Anthropic, OpenAI, Google, xAI, Groq, Cerebras...          │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 各层职责

| 层 | 包名 | 职责 | 权限 |
|---|------|------|------|
| **CLI** | `kodax` | 命令行入口，默认 auto 模式 | 无权限检查 |
| **REPL** | `@kodax/repl` | 交互式 UI，权限管理 | 完整权限控制 |
| **Core** | `@kodax/core` | Agent 循环，工具执行 | 无权限逻辑 |
| **AI** | `@kodax/ai` | LLM 提供商抽象 | N/A |

### 2.3 CLI vs REPL 的区别

| 特性 | CLI 模式 | REPL 模式 |
|------|---------|-----------|
| **默认权限** | auto (YOLO) | default (每次询问) |
| **模式切换** | ❌ 不支持 | ✅ 支持 |
| **权限配置** | ❌ 不读取 | ✅ 读取 |
| **适用场景** | 快速任务执行 | 交互式开发 |
| **用户体验** | 简洁快速 | 精细控制 |

---

## 3. @kodax/ai - LLM 抽象层

### 3.1 设计目标

- **独立包**: 可被其他项目复用
- **统一 API**: 消除提供商差异
- **流式支持**: 所有提供商统一流式接口
- **成本跟踪**: Token 使用量统计

### 3.2 目录结构

```
packages/ai/
├── src/
│   ├── index.ts           # 统一导出
│   ├── types.ts           # 统一类型定义
│   ├── base.ts            # 基类 Provider
│   ├── providers/
│   │   ├── anthropic.ts   # Anthropic Claude
│   │   ├── openai.ts      # OpenAI GPT
│   │   ├── google.ts      # Google Gemini
│   │   ├── xai.ts         # xAI Grok
│   │   ├── groq.ts        # Groq
│   │   ├── cerebras.ts    # Cerebras
│   │   └── openrouter.ts  # OpenRouter 代理
│   ├── utils/
│   │   ├── context-switch.ts  # 跨提供商上下文切换
│   │   ├── cost-tracker.ts    # 成本跟踪
│   │   └── quirks.ts          # 提供商差异处理
│   └── registry.ts        # Provider 注册表
└── package.json
```

### 3.3 统一 API

```typescript
// types.ts

export interface AIProvider {
  name: string;
  isConfigured(): boolean;
  stream(messages: Message[], tools: Tool[], options: StreamOptions): Promise<StreamResult>;
}

export interface StreamOptions {
  systemPrompt?: string;
  thinking?: boolean;
  signal?: AbortSignal;
  onTextDelta?: (text: string) => void;
  onThinkingDelta?: (text: string) => void;
  onToolInputDelta?: (tool: string, json: string) => void;
}

export interface StreamResult {
  textBlocks: TextBlock[];
  toolBlocks: ToolBlock[];
  thinkingBlocks: ThinkingBlock[];
  usage?: UsageInfo;
}
```

### 3.4 提供商差异处理

```typescript
// utils/quirks.ts

export const PROVIDER_QUIRKS = {
  cerebras: {
    disallowedFields: ['store'],
  },
  mistral: {
    tokenField: 'max_tokens',  // 而非 max_completion_tokens
    disallowedFields: ['store', 'developer'],
  },
  grok: {
    disallowedFields: ['reasoning_effort'],
  },
  openai: {
    // OpenAI 特殊处理
  },
  anthropic: {
    // Anthropic thinking block 支持
  },
};
```

### 3.5 使用示例

```typescript
import { getProvider, listProviders } from '@kodax/ai';

// 获取提供商
const provider = getProvider('anthropic');

// 检查配置
if (!provider.isConfigured()) {
  throw new Error('Please set ANTHROPIC_API_KEY');
}

// 流式调用
const result = await provider.stream(messages, tools, {
  systemPrompt: 'You are a coding assistant.',
  thinking: true,
  onTextDelta: (text) => process.stdout.write(text),
});
```

---

## 4. @kodax/core - 纯 Agent 逻辑

### 4.1 重构目标

- **移除权限**: `executeTool()` 不再检查权限
- **移除确认**: 不调用 `ctx.onConfirm`
- **纯粹执行**: 只管执行工具，返回结果

### 4.2 重构前后对比

```typescript
// ===== 重构前 (当前) =====
// registry.ts

export async function executeTool(name: string, input: unknown, ctx: Context) {
  // 1. Plan mode check - 权限检查
  if (ctx.permissionMode === 'plan' && MODIFICATION_TOOLS.has(name)) {
    return { success: false, error: `[Blocked] Not allowed in plan mode` };
  }

  // 2. Protected path check - 权限检查
  if (isAlwaysConfirmPath(input.path, ctx.projectRoot)) {
    const confirmed = await ctx.onConfirm(name, input);  // UI 交互
    if (!confirmed) return { success: false, error: 'Rejected' };
  }

  // 3. Confirm tools check - 权限检查
  if (ctx.confirmTools.has(name)) {
    const confirmed = await ctx.onConfirm(name, input);  // UI 交互
    if (!confirmed) return { success: false, error: 'Rejected' };
  }

  // 4. 执行
  return executeInternal(name, input);
}


// ===== 重构后 =====
// registry.ts

export async function executeTool(name: string, input: unknown): Promise<ToolResult> {
  // 直接执行，无权限检查
  return executeInternal(name, input);
}
```

### 4.3 移除的文件/代码

```
从 core 移除:
├── tools/permission.ts     → 移到 repl 层
├── registry.ts 中的权限检查 → 移到 repl 层
└── types.ts 中的权限类型   → 移到 repl 层
```

### 4.4 简化后的 Context

```typescript
// 重构前
interface KodaXToolExecutionContext {
  permissionMode: PermissionMode;      // 移除
  confirmTools: Set<string>;           // 移除
  alwaysAllowTools: string[];          // 移除
  backups: Map<string, string>;        // 保留
  gitRoot?: string;                    // 保留
  onConfirm?: (...) => Promise<...>;   // 移除
  // ...
}

// 重构后
interface KodaXToolExecutionContext {
  backups: Map<string, string>;
  gitRoot?: string;
  // 仅保留必要的执行上下文
}
```

---

## 5. @kodax/repl - 权限层

### 5.1 新增权限包装器

```typescript
// repl/src/permission-executor.ts

import { executeTool, type ToolResult } from '@kodax/core';

/**
 * 权限包装器 - 在调用 core 前检查权限
 */
export async function executeWithPermission(
  toolName: string,
  input: Record<string, unknown>,
  ctx: PermissionContext
): Promise<ToolResult> {
  const mode = ctx.permissionMode;

  // 1. Plan mode: 阻止所有修改
  if (mode === 'plan' && MODIFICATION_TOOLS.has(toolName)) {
    return { success: false, error: `[Blocked] Not allowed in plan mode` };
  }

  // 2. 项目外路径: 强制确认（所有模式）
  if (isExternalPath(input.path, ctx.projectRoot)) {
    const confirmed = await ctx.showConfirm(toolName, input);
    if (!confirmed) return { success: false, error: '[Rejected] External path' };
  }

  // 3. 模式判断
  const needsConfirm = shouldConfirm(toolName, mode, ctx);

  if (needsConfirm) {
    // 检查 alwaysAllowTools (仅在 accept-edits 模式)
    if (mode === 'accept-edits' && isToolCallAllowed(toolName, input, ctx.alwaysAllowTools)) {
      // 跳过确认
    } else {
      const result = await ctx.showConfirm(toolName, input);
      if (result === 'rejected') {
        return { success: false, error: '[Rejected] User declined' };
      }
      if (result === 'always') {
        ctx.saveAlwaysAllow(toolName, input);
      }
    }
  }

  // 4. 调用 core 执行
  return executeTool(toolName, input);
}

function shouldConfirm(tool: string, mode: PermissionMode, ctx: PermissionContext): boolean {
  switch (mode) {
    case 'plan':
      return true;  // 实际上 plan 模式会直接阻止
    case 'default':
      return ['bash', 'write', 'edit'].includes(tool);
    case 'accept-edits':
      return tool === 'bash';
    case 'auto-in-project':
      return false;  // 项目内全自动
  }
}
```

### 5.2 权限配置加载

```typescript
// repl/src/permission-config.ts (保留)

// 从 .kodax/config.local.json 加载
// 从 ~/.kodax/config.json 加载
// 提供 loadPermissionMode(), loadAlwaysAllowTools() 等
```

---

## 6. CLI - YOLO 模式

### 6.1 简化 CLI

```typescript
// src/kodax_cli.ts

async function runCli(prompt: string) {
  // CLI 默认 auto 模式，无权限检查
  const result = await runKodaX(
    {
      provider: 'anthropic',
      // 不传 permissionMode，CLI 不关心权限
      events: createCliEvents(),  // 简单事件处理
    },
    prompt
  );

  // 直接输出结果
  console.log(result.lastText);
}
```

### 6.2 移除 CLI 参数

```bash
# 重构前
kodax --mode accept-edits "任务描述"
kodax --mode plan "任务描述"

# 重构后
kodax "任务描述"  # 直接执行，无模式切换
```

### 6.3 如果用户需要权限控制

```bash
# 使用交互式 REPL
kodax --interactive

# REPL 中支持模式切换
/mode accept-edits
/mode plan
/mode default
```

---

## 7. 迁移计划

### 7.1 阶段 1: 创建 @kodax/ai 包

1. 创建 `packages/ai/` 目录
2. 从 `core/providers/` 迁移代码
3. 统一 API 接口
4. 处理提供商差异
5. 发布独立包

### 7.2 阶段 2: 重构 @kodax/core

1. 移除 `tools/permission.ts`
2. 简化 `registry.ts` 的 `executeTool()`
3. 简化 Context 类型
4. 更新 `agent.ts` 调用方式

### 7.3 阶段 3: 更新 @kodax/repl

1. 创建 `permission-executor.ts`
2. 迁移权限逻辑
3. 更新 UI 组件调用

### 7.4 阶段 4: 简化 CLI

1. 移除 `--mode` 参数
2. 默认 auto 模式
3. 简化事件处理

---

## 8. 风险与缓解

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| API 变更 | 现有用户代码可能失效 | 保持 `@kodax/core` 导出兼容 |
| 测试覆盖 | 重构可能引入 bug | 增加单元测试 |
| 文档更新 | 用户可能困惑 | 更新 README 和示例 |

---

## 9. 参考资源

- [pi-mono GitHub](https://github.com/badlogic/pi-mono)
- [pi-mono 设计文章](https://mp.weixin.qq.com/s/XRZrOvapXWiZneDtipfHTQ)
- [Terminal-Bench 基准测试](https://github.com/anthonycorletti/terminal-bench)

---

## 10. 决策记录

| 日期 | 决策 | 理由 |
|------|------|------|
| 2026-02-27 | 创建独立的 `@kodax/ai` 包 | 可复用，清晰的职责分离 |
| 2026-02-27 | 从 core 移除权限逻辑 | core 应该是纯执行，无 UI 关注点 |
| 2026-02-27 | CLI 默认 auto 模式 | CLI 用户目标是快速执行 |
| 2026-02-27 | 保留 REPL 权限控制 | 交互式开发需要精细控制 |
