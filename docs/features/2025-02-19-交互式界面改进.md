# 交互式 UI 改进设计文档 v2

> **状态**: ✅ Phase 5 完成 | **更新日期**: 2026-02-20
>
> **技术栈**: React + Ink (React for CLI) - 与 Claude Code / Gemini CLI 一致
>
> **参考实现**: [Gemini CLI](https://github.com/google-gemini/gemini-cli)

---

## 1. 背景与动机

### 1.1 为什么选择 Ink 框架

经过对 Claude Code、Gemini CLI 等 CLI 工具的深入研究，发现它们都采用 **Ink 框架**（React for CLI）构建交互式界面：

| 工具 | 技术栈 | 参考价值 |
|------|--------|----------|
| **Claude Code** | Ink + React | 多行输入、工具执行可视化 |
| **Gemini CLI** | Ink + React | TextBuffer 实现、完整组件库 |
| **OpenCode** | Go + Bubble Tea | Vim 模式、多面板布局 |

**Ink 的优势**：
1. **声明式 UI** - 使用 React 组件模式，代码更清晰
2. **成熟的生态系统** - ink-text-input、ink-spinner 等现成组件
3. **Flexbox 布局** - 使用 Yoga 布局引擎，响应式设计
4. **良好的终端兼容性** - 自动处理 ANSI 转义序列
5. **参考代码丰富** - 可直接参考 Gemini CLI 的实现

### 1.2 当前问题

KodaX 现有 REPL 使用 Node.js `readline` 模块：

```
问题：
├── 每行单独提交，无法在行间移动光标
├── 不支持 raw mode 输入处理
├── 缺乏组件化架构
└── 难以实现复杂的交互功能
```

### 1.3 目标体验

用户应该能够：
1. **多行编辑** - 使用 `↑/↓` 在行间移动光标，`Enter` 提交，`\` + `Enter` 换行
2. **实时补全** - `@` 文件补全、`/` 命令补全
3. **状态可视化** - 底部状态栏显示会话信息
4. **流畅渲染** - 流式 Markdown、代码高亮

---

## 2. 架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        KodaX CLI App                             │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  App.tsx (Ink 根组件)                                      │  │
│  │  ├── <MainContent> - 消息列表渲染                          │  │
│  │  ├── <InputPrompt> - 多行输入框                            │  │
│  │  └── <StatusBar> - 底部状态栏                              │  │
│  └───────────────────────────────────────────────────────────┘  │
│                              │                                   │
│  ┌───────────────────────────▼───────────────────────────────┐  │
│  │  Core Hooks                                                │  │
│  │  ├── useTextBuffer - 文本缓冲区管理                        │  │
│  │  ├── useKeypress - 键盘事件处理                            │  │
│  │  ├── useInputHistory - 输入历史                            │  │
│  │  └── useCompletion - 自动补全                              │  │
│  └───────────────────────────────────────────────────────────┘  │
│                              │                                   │
│  ┌───────────────────────────▼───────────────────────────────┐  │
│  │  Utilities                                                 │  │
│  │  ├── text-buffer.ts - TextBuffer 类                       │  │
│  │  ├── paste-detector.ts - 粘贴检测                         │  │
│  │  ├── text-utils.ts - Unicode 安全操作                     │  │
│  │  └── key-matcher.ts - 快捷键匹配                          │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 目录结构

```
src/
├── ui/                          # Ink UI 组件
│   ├── App.tsx                  # 根组件
│   ├── components/
│   │   ├── InputPrompt.tsx      # 输入框组件
│   │   ├── TextInput.tsx        # 底层文本输入
│   │   ├── MessageList.tsx      # 消息列表
│   │   ├── StatusBar.tsx        # 状态栏
│   │   ├── SuggestionsDisplay.tsx # 补全建议
│   │   └── MarkdownRenderer.tsx # Markdown 渲染
│   ├── hooks/
│   │   ├── useTextBuffer.ts     # TextBuffer Hook
│   │   ├── useKeypress.ts       # 键盘事件
│   │   ├── useInputHistory.ts   # 输入历史
│   │   └── useCompletion.ts     # 自动补全
│   ├── utils/
│   │   ├── text-buffer.ts       # TextBuffer 类
│   │   ├── paste-detector.ts    # 粘贴检测
│   │   ├── text-utils.ts        # Unicode 工具
│   │   └── key-matcher.ts       # 快捷键匹配
│   ├── themes/
│   │   ├── index.ts             # 主题导出
│   │   └── dark.ts              # 默认暗色主题
│   └── types.ts                 # 类型定义
└── interactive/
    └── repl.ts                  # REPL 入口（适配层）
```

---

## 3. 核心组件设计

### 3.1 TextBuffer - 文本缓冲区

参考 Gemini CLI 的 `text-buffer.ts` 实现：

```typescript
// src/ui/utils/text-buffer.ts

export interface CursorPosition {
  row: number;  // 逻辑行号 (0-based)
  col: number;  // 列位置 (code point index)
}

export class TextBuffer {
  private _text: string = '';
  private _lines: string[] = [''];
  private _cursor: CursorPosition = { row: 0, col: 0 };
  private _rememberedCol: number = 0;  // 上下移动时记住的列

  // === Getters ===
  get text(): string { return this._text; }
  get lines(): string[] { return [...this._lines]; }
  get cursor(): CursorPosition { return { ...this._cursor }; }
  get lineCount(): number { return this._lines.length; }

  // === 文本操作 ===
  setText(text: string): void;
  insert(text: string, options?: { paste?: boolean }): void;
  newline(): void;
  backspace(): void;

  // === 光标移动 ===
  move(direction: 'up' | 'down' | 'left' | 'right' | 'home' | 'end'): void;

  // === 行操作 ===
  killLineRight(): void;  // Ctrl+K
  killLineLeft(): void;   // Ctrl+U
  deleteWordLeft(): void; // Ctrl+W
}
```

### 3.2 useTextBuffer Hook

```typescript
// src/ui/hooks/useTextBuffer.ts

export interface UseTextBufferReturn {
  buffer: TextBuffer;
  text: string;
  cursor: CursorPosition;
  setText: (text: string) => void;
  insert: (text: string, options?: { paste?: boolean }) => void;
  newline: () => void;
  backspace: () => void;
  move: (direction: string) => void;
  handleInput: (key: KeyInfo) => boolean;
}

export function useTextBuffer(onSubmit: (text: string) => void): UseTextBufferReturn;
```

### 3.3 InputPrompt 组件

```typescript
// src/ui/components/InputPrompt.tsx

export interface InputPromptProps {
  onSubmit: (text: string) => void;
  placeholder?: string;
  prompt?: string;
  focus?: boolean;
}

export const InputPrompt: React.FC<InputPromptProps>;
```

### 3.4 App 根组件

```typescript
// src/ui/App.tsx

export interface AppProps {
  model: string;
  provider: string;
  onSubmit: (input: string) => Promise<void>;
}

export const App: React.FC<AppProps>;
```

---

## 4. 快捷键设计

| 快捷键 | 功能 | 上下文 |
|--------|------|--------|
| `↑` | 上移一行 / 历史上一条 | 多行时移动光标，第一行时查看历史 |
| `↓` | 下移一行 / 历史下一条 | 多行时移动光标，最后一行时查看历史 |
| `←` | 左移一字符 | - |
| `→` | 右移一字符 | - |
| `Enter` | 提交 | 如果行尾是 `\` 则换行 |
| `Shift+Enter` | 换行 | 始终换行 |
| `Ctrl+A` | 移到行首 | - |
| `Ctrl+E` | 移到行尾 | - |
| `Ctrl+K` | 删除到行尾 | - |
| `Ctrl+U` | 删除到行首 | - |
| `Ctrl+W` | 删除前一词 | - |
| `Ctrl+C` | 清空/退出 | 有内容时清空，无内容时退出 |

---

## 5. 依赖项

```json
{
  "dependencies": {
    "ink": "^5.0.0",
    "react": "^18.2.0",
    "ink-text-input": "^6.0.0",
    "ink-spinner": "^5.0.0",
    "string-width": "^7.0.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.0"
  }
}
```

---

## 6. 实现计划

### Phase 1: 基础架构 ✅ 已完成
- [x] 添加 ink、react 依赖
- [x] 实现 TextBuffer 类 (`src/ui/utils/text-buffer.ts`)
- [x] 实现 useTextBuffer Hook (`src/ui/hooks/useTextBuffer.ts`)
- [x] 实现 useKeypress Hook (`src/ui/hooks/useKeypress.ts`)

### Phase 2: 核心组件 ✅ 已完成
- [x] TextInput 组件 (`src/ui/components/TextInput.tsx`)
- [x] InputPrompt 组件 (`src/ui/components/InputPrompt.tsx`)
- [x] useInputHistory Hook (`src/ui/hooks/useInputHistory.ts`)
- [x] App 根组件 (`src/ui/App.tsx`)

### Phase 3: 增强功能 ✅ 已完成
- [x] StatusBar 组件 (`src/ui/components/StatusBar.tsx`)
- [x] MessageList 组件 (`src/ui/components/MessageList.tsx`)
- [ ] useCompletion Hook (待实现)
- [x] 粘贴检测 (在 useTextBuffer 中实现)

### Phase 4: 集成与优化 ✅ 完成
- [x] REPL 适配层 (`src/ui/InkREPL.tsx`)
- [x] 集成到现有 kodax_cli.ts (`--ink` 参数)
- [x] 主题系统 (`src/ui/themes/`)
- [x] 命令处理集成
- [x] TextBuffer 单元测试 (`tests/text-buffer.test.ts` - 48 tests)

**使用方式**: `kodax --ink` 启用 Ink UI 模式

### Phase 5: 用户体验增强 ✅ 已完成

#### 5.1 启动横幅设计 (Startup Banner)

**目标**: 显示完整的 ASCII 艺术 Logo 和完备的会话信息，提供清晰的用户界面。

**最终设计**:
```
  ██╗  ██╗  ██████╗  ██████╗    █████╗   ██╗  ██╗
  ██║ ██╔╝ ██╔═══██╗ ██╔══██╗  ██╔══██╗  ╚██╗██╔╝
  █████╔╝  ██║   ██║ ██║  ██║  ███████║   ╚███╔╝
  ██╔═██╗  ██║   ██║ ██║  ██║  ██╔══██║   ██╔██╗
  ██║  ██╗ ╚██████╔╝ ██████╔╝  ██║  ██║  ██╔╝ ██╗
  ╚═╝  ╚═╝  ╚═════╝  ╚═════╝   ╚═╝  ╚═╝  ╚═╝  ╚═╝

  v0.3.2 | minimax-coding/MiniMax-M2.5 | code +think +auto
  ─────────────────────────────────────────────────────
  Session: 20260220_143203 | Working: C:\Works\Projects\MarkXbook
  ─────────────────────────────────────────────────────
```

**显示内容**:
1. **ASCII 艺术 Logo** - 6 行高的 KodaX 字母艺术
2. **版本信息** - 当前版本号
3. **Provider/Model** - 当前使用的 AI 模型
4. **模式状态** - code/ask 模式，+think/+auto/+plan 状态
5. **会话信息** - 完整 Session ID（格式: YYYYMMDD_HHMMSS）
6. **工作目录** - 当前项目路径

**文件改动**:
- `src/ui/InkREPL.tsx` - 完整 Banner 组件

#### 5.2 会话历史显示 (Session History Display) ✅ 已完成

**问题**: 恢复会话时（`-c` 或 `-r`），用户无法快速了解之前的对话内容。

**目标**: 启动时显示最近 3-5 条对话历史，帮助用户快速恢复上下文。

**设计**:
```
  [恢复会话 - 最近 5 条对话]
  [用户] 帮我修复 Backspace 键的问题
  [助手] 已修复，问题是 raw mode 下的键盘事件处理...
  [用户] 运行测试
  [助手] 所有 416 个测试通过 ✓
```

**实现要点**:
1. 在 `InkREPL` 组件中获取历史消息
2. 创建 `SessionHistory` 组件显示历史
3. 限制显示条数（默认 5 条）
4. 超长消息截断显示（带省略号）
5. 仅在恢复会话时显示（新会话不显示）

**文件**:
- `src/ui/components/SessionHistory.tsx`

**接口设计**:
```typescript
interface SessionHistoryProps {
  messages: Array<{
    role: 'user' | 'assistant';
    content: string;
    timestamp?: Date;
  }>;
  maxDisplay?: number;  // 默认 5
  maxLength?: number;   // 每条消息最大长度，默认 100
}

export const SessionHistory: React.FC<SessionHistoryProps>;
```

#### 5.3 连贯的历史导航 (Connected History Navigation)

**问题**: 当前的历史导航（上下键）只在当前多行块内移动，无法连续浏览所有历史记录。

**目标**: 实现类似 Claude Code 的连贯历史导航：
- `↑` 在当前行是第一行时，加载上一条历史记录
- `↓` 在当前行是最后一行时，加载下一条历史记录
- 历史记录可以包含多行内容，正确填充到 TextBuffer

**行为设计**:

| 光标位置 | 按键 | 行为 |
|---------|------|------|
| 多行块内部 | `↑` | 移动到上一行 |
| 多行块内部 | `↓` | 移动到下一行 |
| 第一行第一列 | `↑` | 加载上一条历史 |
| 最后一行末尾 | `↓` | 加载下一条历史 |
| 单行输入 | `↑` | 加载上一条历史 |
| 单行输入 | `↓` | 加载下一条历史 |

**实现要点**:
1. 修改 `useInputHistory` Hook，支持多行历史记录
2. 修改 `useTextBuffer` 或 `InputPrompt`，处理边界条件
3. 历史记录存储时保留换行符
4. 导航时光标移动到对应位置（首行或末行）

**文件改动**:
- `src/ui/hooks/useInputHistory.ts` - 支持多行历史
- `src/ui/components/InputPrompt.tsx` - 边界导航逻辑
- `src/ui/utils/text-buffer.ts` - 可能需要辅助方法

**代码示例**:
```typescript
// useInputHistory.ts
interface HistoryEntry {
  text: string;       // 可能包含换行符
  timestamp: number;
}

// InputPrompt.tsx
const handleNavigate = (direction: 'up' | 'down') => {
  const { cursor, lineCount } = buffer;

  if (direction === 'up') {
    // 如果在第一行，尝试加载上一条历史
    if (cursor.row === 0 && cursor.col === 0) {
      const prevHistory = history.previous();
      if (prevHistory) {
        buffer.setText(prevHistory.text);
        buffer.moveToStart(); // 或 moveToEnd()
      }
    } else {
      buffer.move('up');
    }
  }

  if (direction === 'down') {
    // 如果在最后一行末尾，尝试加载下一条历史
    const lastCol = buffer.currentLineLength;
    if (cursor.row === lineCount - 1 && cursor.col >= lastCol) {
      const nextHistory = history.next();
      if (nextHistory) {
        buffer.setText(nextHistory.text);
        buffer.moveToEnd();
      }
    } else {
      buffer.move('down');
    }
  }
};
```

#### 5.4 渲染稳定性优化 (Render Stability) ✅ 已完成

**问题**: 交互一次后 Banner 消失或位置错误，命令输出与 Ink 渲染混在一起导致视觉混乱。

**根本原因**: 混合使用 `console.log`（命令输出）和 Ink 渲染，加上 `showBanner` 状态变化导致布局重渲染。

**研究发现** (参考 Claude Code / Gemini CLI):
- **Claude Code 不使用 alternate screen buffer** - 保留终端滚动历史
- **Gemini CLI 条件使用** - 检测屏幕阅读器时禁用
- **两者都避免混合 console.log 和 Ink 渲染**

**最终解决方案**:
1. **Banner 在 Ink 启动前打印** - 创建 `printStartupBanner()` 函数，在 `render()` 调用前执行
2. **移除组件内的动态内容** - 删除消息列表、状态栏等会随状态变化的组件
3. **使用 `patchConsole: false`** - 允许命令输出正常工作
4. **用户消息用 console.log 输出** - 而不是在组件内渲染

**关键改动**:
```typescript
// 在 Ink render() 之前调用
printStartupBanner(currentConfig, context.sessionId, workingDir);

// Ink 组件只保留输入框
const InkREPL = () => (
  <Box flexDirection="column">
    <InputPrompt onSubmit={handleSubmit} ... />
  </Box>
);

// 用户消息通过 console.log 输出
console.log(chalk.cyan(`You: ${input}`));
```

**预期效果**:
- Banner 启动时显示一次，随内容向上自然滚动（类似 Claude Code）
- 用户消息不会重复渲染
- 命令输出正确追加
- 终端滚动历史完整保留

**文件改动**:
- `src/ui/InkREPL.tsx` - 移除消息列表，简化组件，banner 打印移到 render() 前
- `tests/banner.test.ts` - 新增 Banner 稳定性测试

#### Phase 5 任务清单

| 任务 | 优先级 | 文件 | 状态 |
|------|--------|------|------|
| 5.1.1 恢复完整 ASCII 艺术 Logo | P0 | `InkREPL.tsx` | ✅ 已完成 |
| 5.1.2 显示版本/Provider/Mode 信息 | P0 | `InkREPL.tsx` | ✅ 已完成 |
| 5.1.3 显示 Session ID 和工作目录 | P0 | `InkREPL.tsx` | ✅ 已完成 |
| 5.2.1 创建 SessionHistory 组件 | P1 | `SessionHistory.tsx` | ✅ 已完成 |
| 5.2.2 集成到 InkREPL 启动流程 | P1 | `InkREPL.tsx` | ✅ 已完成 |
| 5.3.1 修改 useInputHistory 支持多行 | P0 | `useInputHistory.ts` | ✅ 已支持 |
| 5.3.2 实现边界历史导航逻辑 | P0 | `InputPrompt.tsx` | ✅ 已完成 |
| 5.3.3 添加单元测试 | P1 | `tests/` | ✅ 已完成 |
| 5.4.1 修复渲染稳定性问题 | P0 | `InkREPL.tsx` | ✅ 已完成 |
| 5.4.2 移除消息列表组件 | P1 | `InkREPL.tsx` | ✅ 已完成 |
| 5.4.3 Banner 移到 Ink render() 前 | P0 | `InkREPL.tsx` | ✅ 已完成 |
| 5.4.4 添加 Banner 稳定性测试 | P2 | `tests/banner.test.ts` | ✅ 已完成 |

---

## 7. 参考

- [Gemini CLI text-buffer.ts](https://github.com/google-gemini/gemini-cli/blob/master/packages/cli/src/ui/components/shared/text-buffer.ts)
- [Gemini CLI InputPrompt.tsx](https://github.com/google-gemini/gemini-cli/blob/master/packages/cli/src/ui/components/InputPrompt.tsx)
- [Ink GitHub](https://github.com/vadimdemedes/ink)
- [Memo Code 输入框实现](https://juejin.cn/post/7605800124883288070)

---

## 8. 风险与回滚

| 风险 | 可能性 | 应对措施 |
|------|--------|----------|
| Ink 与现有 CLI 冲突 | 低 | 使用适配层隔离 |
| React 首次渲染延迟 | 低 | 使用静态内容优化 |
| 终端兼容性问题 | 中 | 检测终端能力降级 |

### 回滚方案
- 保留原有 `repl.ts` 作为 `repl-legacy.ts`
- 通过 `--legacy-ui` 参数切换

### 4.1 架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                     交互式 REPL 层                           │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  repl.ts (主循环)                                    │   │
│  │  ├── 多行输入处理                                    │   │
│  │  ├── 快捷键绑定                                      │   │
│  │  └── 状态栏集成                                      │   │
│  └──────────────────────┬──────────────────────────────┘   │
│                         │                                   │
│  ┌──────────────────────▼──────────────────────────────┐   │
│  │  status-bar.ts (新建)                                │   │
│  │  ├── StatusBar 类                                    │   │
│  │  ├── render() - 渲染状态栏                           │   │
│  │  ├── update() - 更新状态                              │   │
│  │  └── hide()/show() - 显示控制                        │   │
│  └──────────────────────┬──────────────────────────────┘   │
│                         │                                   │
│  ┌──────────────────────▼──────────────────────────────┐   │
│  │  autocomplete.ts (新建)                              │   │
│  │  ├── completeFilePath() - 文件路径补全                │   │
│  │  ├── completeCommand() - 命令补全                     │   │
│  │  └── Completer 接口                                  │   │
│  └──────────────────────┬──────────────────────────────┘   │
│                         │                                   │
│  ┌──────────────────────▼──────────────────────────────┐   │
│  │  themes.ts (新建)                                    │   │
│  │  ├── Theme 接口                                      │   │
│  │  ├── themes.dark / themes.light / themes.minimal     │   │
│  │  └── applyTheme()                                    │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│                     CLI 输出层                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  kodax_cli.ts                                        │   │
│  │  ├── 流式 Markdown 渲染                              │   │
│  │  ├── 代码语法高亮                                    │   │
│  │  └── 工具进度可视化                                  │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### 4.2 数据结构

#### 4.2.1 StatusBar 接口

```typescript
// src/interactive/status-bar.ts

export interface StatusBarState {
  sessionId: string;           // 简短会话 ID
  mode: 'code' | 'ask';        // 当前模式
  provider: string;            // Provider 名称
  model: string;               // 模型名称
  tokenUsage?: {
    input: number;
    output: number;
    total: number;
  };
  currentTool?: string;        // 当前执行的工具
  projectInfo?: {
    name: string;
    completedFeatures: number;
    totalFeatures: number;
  };
}

export class StatusBar {
  private state: StatusBarState;
  private visible: boolean;
  private terminalWidth: number;

  constructor(initialState: StatusBarState);

  render(): void;
  update(updates: Partial<StatusBarState>): void;
  show(): void;
  hide(): void;
  setPosition(x: number, y: number): void;
}
```

#### 4.2.2 Completer 接口

```typescript
// src/interactive/autocomplete.ts

export interface Completion {
  text: string;                // 补全文本
  display: string;             // 显示文本
  description?: string;        // 描述
  type: 'file' | 'command' | 'argument';
}

export interface Completer {
  canComplete(input: string, cursorPos: number): boolean;
  getCompletions(input: string, cursorPos: number): Promise<Completion[]>;
}

export class FileCompleter implements Completer {
  // @file 补全
}

export class CommandCompleter implements Completer {
  // /command 补全
}
```

#### 4.2.3 Theme 接口

```typescript
// src/interactive/themes.ts

export interface ThemeColors {
  primary: string;             // 主色调
  secondary: string;           // 次要颜色
  accent: string;              // 强调色
  text: string;                // 文本颜色
  dim: string;                 // 暗淡文本
  success: string;             // 成功状态
  warning: string;             // 警告状态
  error: string;               // 错误状态
  spinner: string[];           // Spinner 颜色序列
}

export interface Theme {
  name: string;
  colors: ThemeColors;
  symbols: {
    prompt: string;
    success: string;
    error: string;
    warning: string;
    spinner: string[];
  };
}

export const themes: Record<string, Theme>;
```

### 4.3 命令处理器

```typescript
// src/interactive/repl.ts

// 快捷键映射
const KEYBOARD_SHORTCUTS: Record<string, () => void> = {
  // Ctrl+O: 切换工具输出显示
  '\x0f': () => toggleToolOutput(),

  // Ctrl+T: 显示 Todo 列表
  '\x14': () => showTodoList(),

  // Ctrl+R: 历史搜索 (readline 内置)
  // Ctrl+C: 取消 (readline 内置)

  // Ctrl+J: 多行输入换行
  '\x0a': () => insertNewline(),
};

// 多行输入处理
function handleMultilineInput(input: string): string[] {
  const lines: string[] = [];
  let currentLine = input;

  while (true) {
    if (currentLine.endsWith('\\')) {
      // 续行符
      lines.push(currentLine.slice(0, -1));
      currentLine = await readNextLine('... ');
    } else if (hasOpenBrackets(currentLine)) {
      // 括号未闭合
      lines.push(currentLine);
      currentLine = await readNextLine('... ');
    } else {
      lines.push(currentLine);
      break;
    }
  }

  return lines;
}
```

### 4.4 确认提示增强

```typescript
// src/interactive/prompts.ts

export interface ConfirmOptions {
  message: string;
  default?: 'y' | 'n';
  options?: Array<{
    key: string;
    label: string;
    description: string;
  }>;
}

export async function confirmEnhanced(options: ConfirmOptions): Promise<string> {
  const { message, default: defaultVal, options: customOptions } = options;

  // 默认选项
  const opts = customOptions || [
    { key: 'y', label: 'Yes', description: '确认执行' },
    { key: 'n', label: 'No', description: '取消操作' },
  ];

  // 渲染选项
  const optionsText = opts.map(o =>
    chalk.dim(`[${o.key}]`) + ` ${o.label}`
  ).join(' ');

  console.log(chalk.cyan(`\n? ${message}`));
  console.log(chalk.dim(`  ${optionsText}`));

  const answer = await readLine(`  Choose: `);

  return answer.toLowerCase() || defaultVal || 'n';
}
```

---

## 5. 实现计划

### Phase 1: 基础增强 (P0)

| 任务 | 文件 | 改动 |
|------|------|------|
| 1.1 | `src/interactive/prompts.ts` | 新增：增强确认提示组件 |
| 1.2 | `src/interactive/repl.ts` | 添加：响应式布局检测 |
| 1.3 | `src/interactive/repl.ts` | 添加：键盘快捷键绑定 |

### Phase 2: 核心 UI (P0)

| 任务 | 文件 | 改动 |
|------|------|------|
| 2.1 | `src/interactive/repl.ts` | 实现：多行输入 (Ctrl+J) |
| 2.2 | `src/interactive/status-bar.ts` | 新增：状态栏组件 |
| 2.3 | `src/kodax_cli.ts` | 增强：进度可视化 |

### Phase 3: 高级功能 (P1)

| 任务 | 文件 | 改动 |
|------|------|------|
| 3.1 | `src/interactive/autocomplete.ts` | 新增：自动补全 |
| 3.2 | `src/kodax_cli.ts` | 增强：流式 Markdown |
| 3.3 | `src/kodax_cli.ts` | 增强：工具进度追踪 |

### Phase 4: 润色 (P2)

| 任务 | 文件 | 改动 |
|------|------|------|
| 4.1 | `src/interactive/themes.ts` | 新增：主题系统 |
| 4.2 | `src/interactive/repl.ts` | 增强：命令历史 |
| 4.3 | `src/interactive/repl.ts` | 增强：Todo UI |

---

## 6. 关键决策总结

| 决策 | 选择 | 理由 |
|------|------|------|
| 多行输入 | Ctrl+J 换行 | 兼容性最好 |
| 状态栏 | 底部固定 | 信息展示完整 |
| 自动补全 | readline 原生 | 无需新依赖 |
| 主题 | 先 dark 主题 | 终端用户偏好 |

---

## 7. 风险与回滚

### 潜在风险

| 风险 | 可能性 | 应对措施 |
|------|--------|----------|
| ANSI 转义序列兼容性 | 中 | 检测终端能力，降级处理 |
| 状态栏与输出冲突 | 低 | 使用备用屏幕缓冲区 |
| 补全性能问题 | 低 | 异步加载，缓存结果 |

### 回滚方案

- 每个功能模块独立，可单独禁用
- 通过配置项 `ui.features` 控制功能开关
- 状态栏可通过 `--no-status-bar` 参数禁用

---

## 8. 与其他 CLI 工具的对比

| 功能 | Claude Code | Gemini CLI | Aider | KodaX (改进后) |
|------|-------------|------------|-------|----------------|
| 多行输入 | ✅ | ✅ | ✅ | ✅ |
| 文件补全 | ✅ | ✅ | ✅ | ✅ |
| 命令补全 | ✅ | ✅ | ✅ | ✅ |
| 状态栏 | ❌ | ❌ | ✅ | ✅ |
| 主题 | ❌ | ❌ | ❌ | ✅ |
| 键盘快捷键 | ✅ | 部分 | 部分 | ✅ |
| Markdown 高亮 | ✅ | ✅ | ❌ | ✅ |

---

## 9. 后续优化方向

1. **外部编辑器集成**：Ctrl+E 打开 $EDITOR 编辑多行输入
2. **模糊搜索**：fzf 风格的文件/命令搜索
3. **分屏显示**：工具输出与对话分屏
4. **鼠标支持**：点击选择补全项
5. **Web UI**：可选的浏览器界面
